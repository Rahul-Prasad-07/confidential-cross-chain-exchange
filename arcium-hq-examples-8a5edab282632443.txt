Directory structure:
└── arcium-hq-examples/
    ├── README.md
    ├── blackjack/
    │   ├── README.md
    │   ├── Anchor.toml
    │   ├── Arcium.toml
    │   ├── Cargo.toml
    │   ├── package.json
    │   ├── rust-toolchain
    │   ├── tsconfig.json
    │   ├── .prettierignore
    │   ├── encrypted-ixs/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   ├── migrations/
    │   │   └── deploy.ts
    │   ├── programs/
    │   │   └── blackjack/
    │   │       ├── Cargo.toml
    │   │       ├── Xargo.toml
    │   │       └── src/
    │   │           └── lib.rs
    │   └── tests/
    │       └── blackjack.ts
    ├── coinflip/
    │   ├── README.md
    │   ├── Anchor.toml
    │   ├── Arcium.toml
    │   ├── Cargo.toml
    │   ├── package.json
    │   ├── rust-toolchain
    │   ├── tsconfig.json
    │   ├── .prettierignore
    │   ├── encrypted-ixs/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   ├── migrations/
    │   │   └── deploy.ts
    │   ├── programs/
    │   │   └── coinflip/
    │   │       ├── Cargo.toml
    │   │       ├── Xargo.toml
    │   │       └── src/
    │   │           └── lib.rs
    │   └── tests/
    │       └── coinflip.ts
    ├── rock_paper_scissors/
    │   ├── README.md
    │   ├── against-house/
    │   │   ├── README.md
    │   │   ├── Anchor.toml
    │   │   ├── Arcium.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── rust-toolchain
    │   │   ├── tsconfig.json
    │   │   ├── .prettierignore
    │   │   ├── encrypted-ixs/
    │   │   │   ├── Cargo.toml
    │   │   │   └── src/
    │   │   │       └── lib.rs
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── programs/
    │   │   │   └── rock_paper_scissors_against_rng/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── rock_paper_scissors_against_rng.ts
    │   └── against-player/
    │       ├── README.md
    │       ├── Anchor.toml
    │       ├── Arcium.toml
    │       ├── Cargo.toml
    │       ├── package.json
    │       ├── rust-toolchain
    │       ├── tsconfig.json
    │       ├── .prettierignore
    │       ├── encrypted-ixs/
    │       │   ├── Cargo.toml
    │       │   └── src/
    │       │       └── lib.rs
    │       ├── migrations/
    │       │   └── deploy.ts
    │       ├── programs/
    │       │   └── rock_paper_scissors/
    │       │       ├── Cargo.toml
    │       │       ├── Xargo.toml
    │       │       └── src/
    │       │           └── lib.rs
    │       └── tests/
    │           └── rock_paper_scissors.ts
    ├── share_medical_records/
    │   ├── README.md
    │   ├── Anchor.toml
    │   ├── Arcium.toml
    │   ├── Cargo.toml
    │   ├── package.json
    │   ├── rust-toolchain
    │   ├── tsconfig.json
    │   ├── .prettierignore
    │   ├── encrypted-ixs/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   ├── migrations/
    │   │   └── deploy.ts
    │   ├── programs/
    │   │   └── share_medical_records/
    │   │       ├── Cargo.toml
    │   │       ├── Xargo.toml
    │   │       └── src/
    │   │           └── lib.rs
    │   └── tests/
    │       └── share_medical_records.ts
    ├── voting/
    │   ├── README.md
    │   ├── Anchor.toml
    │   ├── Arcium.toml
    │   ├── Cargo.toml
    │   ├── package.json
    │   ├── rust-toolchain
    │   ├── tsconfig.json
    │   ├── .prettierignore
    │   ├── encrypted-ixs/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   ├── migrations/
    │   │   └── deploy.ts
    │   ├── programs/
    │   │   └── voting/
    │   │       ├── Cargo.toml
    │   │       ├── Xargo.toml
    │   │       └── src/
    │   │           └── lib.rs
    │   └── tests/
    │       └── voting.ts
    └── .github/
        ├── actions/
        │   ├── setup/
        │   │   └── action.yaml
        │   ├── setup-anchor/
        │   │   └── action.yaml
        │   ├── setup-arcium/
        │   │   └── action.yaml
        │   └── setup-solana/
        │       └── action.yaml
        └── workflows/
            ├── fmt.yaml
            └── test-examples.yaml

================================================
FILE: README.md
================================================
# Arcium Examples

This repository contains example applications demonstrating how to build confidential applications on Solana using Arcium's Multi-Party Computation (MPC) network. Each example showcases different aspects of privacy-preserving computation while maintaining transparency and verifiability on the blockchain.

## Getting Started

To build and run these examples, you'll need:

- Rust toolchain
- Solana CLI tools  
- Anchor framework
- Access to Arcium's MPC network

For detailed setup instructions, check out our [Developer Documentation](https://docs.arcium.com/developers).

## Examples

### Gaming Applications

**[Blackjack](./blackjack/)** - A complete blackjack game where card values remain hidden throughout gameplay. Demonstrates complex game state management with encrypted data structures and multi-step MPC computations for card dealing, player actions, and game resolution.

**[Coin Flip](./coinflip/)** - A simple heads-or-tails game showcasing secure random number generation within MPC. Players submit encrypted choices that are compared against cryptographically secure randomness generated by the network.

**[Rock Paper Scissors](./rock_paper_scissors/)** - Two variants of the classic game:
- **[Player vs Player](./rock_paper_scissors/against-player/)** - Both players submit secret moves that are revealed and compared simultaneously
- **[Player vs House](./rock_paper_scissors/against-house/)** - Player competes against randomly generated house moves

### Governance & Privacy

**[Confidential Voting](./voting/)** - Anonymous polling system where individual votes remain private while still enabling verifiable tallying. Demonstrates how to maintain voter privacy while ensuring election integrity.

**[Medical Records Sharing](./share_medical_records/)** - Privacy-preserving healthcare data sharing between authorized parties. Shows how sensitive personal information can be shared selectively while maintaining confidentiality.

## Architecture

These examples demonstrate building confidential applications using Arcium's MPC network. Each follows a similar pattern:

1. **Solana Program** - Manages on-chain state and orchestrates MPC operations
2. **MPC Instructions** - Define computations over encrypted data executed by Arcium nodes
3. **Client SDK** - Handles encryption/decryption and interaction with both Solana and Arcium

For detailed documentation on Arcium's architecture and APIs, see [docs.arcium.com/developers](https://docs.arcium.com/developers).

## Support

Questions? Join our [Discord community](https://discord.com/invite/arcium) for help and discussion. 



================================================
FILE: blackjack/README.md
================================================
# Confidential Blackjack on Solana

This example demonstrates a fully confidential blackjack game implemented using Arcium's Multi-Party Computation network. Players can enjoy a complete blackjack experience while keeping all card information private throughout the game.

## How Blackjack Works

Blackjack is a card game where players try to get their hand value as close to 21 as possible without going over (busting). Card values are:

- Number cards (2-10): Face value
- Face cards (Jack, Queen, King): 10 points each  
- Aces: 1 or 11 points (whichever is better for the hand)

The player receives two cards initially and can choose to "hit" (take another card), "stand" (keep current hand), or "double down" (double the bet and take exactly one more card). The dealer follows fixed rules: hit on 16 or less, stand on 17 or more.

## Why Arcium is Essential

Traditional on-chain card games face a fundamental problem: blockchain transparency means all data is public. In blackjack, if card values were visible, players could see the dealer's hole card and upcoming cards in the deck, completely breaking the game's fairness.

Arcium solves this by:

- **Confidential Deck Shuffling**: The 52-card deck is shuffled using cryptographically secure randomness within MPC
- **Private Card Values**: Player and dealer hands remain encrypted throughout gameplay
- **Hidden Information**: Players can't see the dealer's hole card or future cards in the deck
- **Fair Gameplay**: Only necessary information is revealed (like whether a player busted) while maintaining game integrity

## Technical Implementation

### Deck Encoding Innovation

The most complex part of this implementation is efficiently storing a 52-card deck in encrypted form. The solution uses a clever base-64 encoding scheme:

- Each card is represented as a 6-bit value (0-63 range)
- Multiple cards are packed into u128 integers using powers of 64
- The full deck splits across three u128 values for storage efficiency
- Cards 0-20 go in the first u128, cards 21-41 in the second, cards 42-51 in the third

This encoding allows the entire shuffled deck to be stored and manipulated within MPC while remaining completely confidential.

### Game Flow

1. **Initialization**: Player creates a game session and the deck is shuffled in MPC
2. **Deal**: Initial cards are dealt (2 to player, 2 to dealer with 1 face up)  
3. **Player Turn**: Player can hit, stand, or double down based on their encrypted hand
4. **Dealer Turn**: Dealer follows standard rules within MPC computation
5. **Resolution**: Final hand comparison determines the winner

### MPC Operations

Each game action triggers a specific MPC computation:

- `shuffle_and_deal_cards`: Initial deck shuffle and card dealing
- `player_hit`: Drawing additional cards for the player
- `player_stand`: Checking if player's current hand is valid
- `player_double_down`: Taking exactly one more card with doubled stakes
- `dealer_play`: Dealer follows hitting rules until reaching 17+
- `resolve_game`: Final comparison to determine the winner

All computations maintain card confidentiality while revealing only the minimum information needed for gameplay.

## Project Structure

**In order to build this project, cargo will require access to the arcium registry where the arcium dependencies are published to.
This is done by editing the generated `.cargo/credentials.toml` file to the root of the project with the provided token.**

The project follows Arcium's standard structure:

- `programs/blackjack/` - Solana program handling game state and user interactions
- `encrypted-ixs/` - MPC computations for confidential card operations  
- `tests/` - Integration tests demonstrating complete game flows
- `app/` - Frontend application for playing the game

The confidential computations in `encrypted-ixs/` handle all card-related logic while the Solana program manages game sessions, player accounts, and state transitions.



================================================
FILE: blackjack/Anchor.toml
================================================
[toolchain]
package_manager = "yarn"

[features]
resolution = true
skip-lint = false

[programs.localnet]
blackjack = "DQxanaqqWcTYvVhrKbeoY6q52NrGksWBL6vSbuVipnS7"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"



================================================
FILE: blackjack/Arcium.toml
================================================
[localnet]
# number of nodes in the single cluster of the localnet
nodes = 2
# number of seconds to wait for the localnet to come online
localnet_timeout_secs = 60
# MPC backends this MXE supports (default: ["Cerberus"])
# Supported values: "Cerberus", "Manticore", or both
# Examples: backends = ["Cerberus"] or backends = ["Cerberus", "Manticore"]
backends = ["Cerberus"]
# Required when backends includes "Manticore"
# Each path is copied to corresponding node's artifacts/manticore/computation_folder_N
# Example: manticore_data_folders = ["./data/player-0", "./data/player-1"]
# manticore_data_folders = []


================================================
FILE: blackjack/Cargo.toml
================================================
[workspace]
members = ["programs/*", "encrypted-ixs"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
[patch.crates-io]
proc-macro2 = { git = 'https://github.com/arcium-hq/proc-macro2.git' }


================================================
FILE: blackjack/package.json
================================================
{
  "license": "ISC",
  "scripts": {
    "lint:fix": "prettier */*.js \"*/**/*{.js,.ts}\" -w",
    "lint": "prettier */*.js \"*/**/*{.js,.ts}\" --check"
  },
  "dependencies": {
    "@coral-xyz/anchor": "^0.31.1",
    "@arcium-hq/client": "0.3.0"
  },
  "devDependencies": {
    "chai": "^4.3.4",
    "mocha": "^9.0.3",
    "ts-mocha": "^10.0.0",
    "@types/bn.js": "^5.1.0",
    "@types/chai": "^4.3.0",
    "@types/mocha": "^9.0.0",
    "typescript": "^4.3.5",
    "prettier": "^2.6.2"
  }
}



================================================
FILE: blackjack/rust-toolchain
================================================
1.88.0



================================================
FILE: blackjack/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2020"],
    "module": "commonjs",
    "target": "es2020",
    "esModuleInterop": true,
    "resolveJsonModule": true
  }
}



================================================
FILE: blackjack/.prettierignore
================================================
.anchor
.DS_Store
target
node_modules
dist
build
test-ledger



================================================
FILE: blackjack/encrypted-ixs/Cargo.toml
================================================
[package]
name = "encrypted-ixs"
version = "0.1.0"
edition = "2021"

[dependencies]
arcis-imports = { version = "0.3.0" }


================================================
FILE: blackjack/encrypted-ixs/src/lib.rs
================================================
use arcis_imports::*;

#[encrypted]
mod circuits {
    use arcis_imports::*;

    /// Standard 52-card deck represented as indices 0-51
    const INITIAL_DECK: [u8; 52] = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
        48, 49, 50, 51,
    ];

    /// Powers of 64 used for encoding cards into u128 values.
    /// Each card takes 6 bits (values 0-63), so we can pack multiple cards efficiently.
    /// This array contains 64^i for i in 0..21, allowing us to encode up to 21 cards per u128.
    const POWS_OF_SIXTY_FOUR: [u128; 21] = [
        1,
        64,
        4096,
        262144,
        16777216,
        1073741824,
        68719476736,
        4398046511104,
        281474976710656,
        18014398509481984,
        1152921504606846976,
        73786976294838206464,
        4722366482869645213696,
        302231454903657293676544,
        19342813113834066795298816,
        1237940039285380274899124224,
        79228162514264337593543950336,
        5070602400912917605986812821504,
        324518553658426726783156020576256,
        20769187434139310514121985316880384,
        1329227995784915872903807060280344576,
    ];

    /// Represents a full 52-card deck encoded into three u128 values for efficiency.
    ///
    /// Each card is represented by 6 bits (0-63 range), allowing us to pack:
    /// - Cards 0-20 in card_one (21 cards × 6 bits = 126 bits < 128 bits)
    /// - Cards 21-41 in card_two (21 cards × 6 bits = 126 bits < 128 bits)  
    /// - Cards 42-51 in card_three (10 cards × 6 bits = 60 bits < 128 bits)
    pub struct Deck {
        pub card_one: u128,
        pub card_two: u128,
        pub card_three: u128,
    }

    impl Deck {
        /// Converts a 52-card array into the packed Deck representation.
        /// Uses base-64 encoding where each card index is treated as a digit in base 64.
        pub fn from_array(array: [u8; 52]) -> Deck {
            let mut card_one = 0;
            for i in 0..21 {
                card_one += POWS_OF_SIXTY_FOUR[i] * array[i] as u128;
            }

            let mut card_two = 0;
            for i in 21..42 {
                card_two += POWS_OF_SIXTY_FOUR[i - 21] * array[i] as u128;
            }

            let mut card_three = 0;
            for i in 42..52 {
                card_three += POWS_OF_SIXTY_FOUR[i - 42] * array[i] as u128;
            }

            Deck {
                card_one,
                card_two,
                card_three,
            }
        }

        /// Converts the packed Deck representation back to a 52-card array.
        /// Reverses the base-64 encoding by extracting 6 bits at a time.
        fn to_array(&self) -> [u8; 52] {
            let mut card_one = self.card_one;
            let mut card_two = self.card_two;
            let mut card_three = self.card_three;

            let mut bytes = [0u8; 52];
            for i in 0..21 {
                bytes[i] = (card_one % 64) as u8;
                bytes[i + 21] = (card_two % 64) as u8;
                card_one >>= 6;
                card_two >>= 6;
            }

            for i in 42..52 {
                bytes[i] = (card_three % 64) as u8;
                card_three >>= 6;
            }

            bytes
        }
    }

    // Initial hand is 2 player cards and 2 dealer cards (1 face up, 1 face down)
    pub struct InitialHandVisible {
        pub player_card_one: u8,
        pub player_card_two: u8,
        pub dealer_card_one: u8,
    }

    pub struct Hand {
        pub cards: u128,
    }

    impl Hand {
        pub fn from_array(array: [u8; 11]) -> Hand {
            let mut cards = 0;
            for i in 0..11 {
                cards += POWS_OF_SIXTY_FOUR[i] * array[i] as u128;
            }

            Hand { cards }
        }

        fn to_array(&self) -> [u8; 11] {
            let mut cards = self.cards;

            let mut bytes = [0u8; 11];
            for i in 0..11 {
                bytes[i] = (cards % 64) as u8;
                cards >>= 6;
            }

            bytes
        }
    }

    #[instruction]
    pub fn shuffle_and_deal_cards(
        mxe: Mxe,
        mxe_again: Mxe,
        client: Shared,
        client_again: Shared,
    ) -> (
        Enc<Mxe, Deck>,    // 16 + 32 x 3
        Enc<Mxe, Hand>,    // 16 + 32
        Enc<Shared, Hand>, // 32 + 16 + 32
        Enc<Shared, u8>,   // 32 + 16 + 32
    ) {
        let mut initial_deck = INITIAL_DECK;
        ArcisRNG::shuffle(&mut initial_deck);

        let deck = mxe.from_arcis(Deck::from_array(initial_deck));

        let mut dealer_cards = [53; 11];
        dealer_cards[0] = initial_deck[1];
        dealer_cards[1] = initial_deck[3];

        let dealer_hand = mxe_again.from_arcis(Hand::from_array(dealer_cards));

        let mut player_cards = [53; 11];
        player_cards[0] = initial_deck[0];
        player_cards[1] = initial_deck[2];

        let player_hand = client.from_arcis(Hand::from_array(player_cards));

        (
            deck,
            dealer_hand,
            player_hand,
            client_again.from_arcis(initial_deck[1]),
        )
    }

    #[instruction]
    pub fn player_hit(
        deck_ctxt: Enc<Mxe, Deck>,
        player_hand_ctxt: Enc<Shared, Hand>,
        player_hand_size: u8,
        dealer_hand_size: u8,
    ) -> (Enc<Shared, Hand>, bool) {
        let deck = deck_ctxt.to_arcis().to_array();

        let mut player_hand = player_hand_ctxt.to_arcis().to_array();

        let player_hand_value = calculate_hand_value(&player_hand, player_hand_size);

        let is_bust = player_hand_value > 21;

        let new_card = if !is_bust {
            let card_index = (player_hand_size + dealer_hand_size) as usize;

            // Get the next card from the deck
            deck[card_index]
        } else {
            53
        };

        player_hand[player_hand_size as usize] = new_card;

        let player_updated_hand_value = calculate_hand_value(&player_hand, player_hand_size + 1);

        (
            player_hand_ctxt
                .owner
                .from_arcis(Hand::from_array(player_hand)),
            is_bust.reveal(),
        )
    }

    // Returns true if the player has busted
    #[instruction]
    pub fn player_stand(player_hand_ctxt: Enc<Shared, Hand>, player_hand_size: u8) -> bool {
        let player_hand = player_hand_ctxt.to_arcis().to_array();
        let value = calculate_hand_value(&player_hand, player_hand_size);
        (value > 21).reveal()
    }

    // Returns true if the player has busted, if not, returns the new card
    #[instruction]
    pub fn player_double_down(
        deck_ctxt: Enc<Mxe, Deck>,
        player_hand_ctxt: Enc<Shared, Hand>,
        player_hand_size: u8,
        dealer_hand_size: u8,
    ) -> (Enc<Shared, Hand>, bool) {
        let deck = deck_ctxt.to_arcis();
        let deck_array = deck.to_array();

        let mut player_hand = player_hand_ctxt.to_arcis().to_array();

        let player_hand_value = calculate_hand_value(&player_hand, player_hand_size);

        let is_bust = player_hand_value > 21;

        let new_card = if !is_bust {
            let card_index = (player_hand_size + dealer_hand_size) as usize;

            // Get the next card from the deck
            deck_array[card_index]
        } else {
            53
        };

        player_hand[player_hand_size as usize] = new_card;

        (
            player_hand_ctxt
                .owner
                .from_arcis(Hand::from_array(player_hand)),
            is_bust.reveal(),
        )
    }

    // Function for dealer to play (reveal hole card and follow rules)
    #[instruction]
    pub fn dealer_play(
        deck_ctxt: Enc<Mxe, Deck>,
        dealer_hand_ctxt: Enc<Mxe, Hand>,
        client: Shared,
        player_hand_size: u8,
        dealer_hand_size: u8,
    ) -> (Enc<Mxe, Hand>, Enc<Shared, Hand>, u8) {
        let deck = deck_ctxt.to_arcis();
        let mut deck_array = deck.to_array();
        let mut dealer = dealer_hand_ctxt.to_arcis().to_array();
        let mut size = dealer_hand_size as usize;

        for i in 0..7 {
            let val = calculate_hand_value(&dealer, size as u8);
            if val < 17 {
                let idx = (player_hand_size as usize + size) as usize;
                dealer[size] = deck_array[idx];
                size += 1;
            }
        }

        (
            dealer_hand_ctxt.owner.from_arcis(Hand::from_array(dealer)),
            client.from_arcis(Hand::from_array(dealer)),
            (size as u8).reveal(),
        )
    }

    /// Calculates the blackjack value of a hand according to standard rules.
    ///
    /// Card values: Ace = 1 or 11 (whichever is better), Face cards = 10, Others = face value.
    /// Aces are initially valued at 11, but automatically reduced to 1 if the hand would bust.
    ///
    /// # Arguments
    /// * `hand` - Array of up to 11 cards (more than enough for blackjack)
    /// * `hand_length` - Number of actual cards in the hand
    ///
    /// # Returns
    /// The total value of the hand (1-21, or >21 if busted)
    fn calculate_hand_value(hand: &[u8; 11], hand_length: u8) -> u8 {
        let mut value = 0;
        let mut has_ace = false;

        // Process each card in the hand
        for i in 0..11 {
            let rank = if i < hand_length as usize {
                (hand[i] % 13) // Card rank (0=Ace, 1-9=pip cards, 10-12=face cards)
            } else {
                0
            };

            if i < hand_length as usize {
                if rank == 0 {
                    // Ace: start with value of 11
                    value += 11;
                    has_ace = true;
                } else if rank > 10 {
                    // Face cards (Jack, Queen, King): value of 10
                    value += 10;
                } else {
                    // Pip cards (2-10): face value (rank 1-9 becomes value 1-9)
                    value += rank;
                }
            }
        }

        // Convert Ace from 11 to 1 if hand would bust with 11
        if value > 21 && has_ace {
            value -= 10;
        }

        value
    }

    /// Determines the final winner of the blackjack game.
    ///
    /// Compares the final hand values according to blackjack rules and returns
    /// a numeric result indicating the outcome. Both hands are evaluated for busts
    /// and compared for the winner.
    ///
    /// # Returns
    /// * 0 = Player busts (dealer wins)
    /// * 1 = Dealer busts (player wins)
    /// * 2 = Player wins (higher value, no bust)
    /// * 3 = Dealer wins (higher value, no bust)
    /// * 4 = Push/tie (same value, no bust)
    #[instruction]
    pub fn resolve_game(
        player_hand: Enc<Shared, Hand>,
        dealer_hand: Enc<Mxe, Hand>,
        player_hand_length: u8,
        dealer_hand_length: u8,
    ) -> u8 {
        let player_hand = player_hand.to_arcis().to_array();
        let dealer_hand = dealer_hand.to_arcis().to_array();

        // Calculate final hand values
        let player_value = calculate_hand_value(&player_hand, player_hand_length);
        let dealer_value = calculate_hand_value(&dealer_hand, dealer_hand_length);

        // Apply blackjack rules to determine winner
        let result = if player_value > 21 {
            0 // Player busts - dealer wins automatically
        } else if dealer_value > 21 {
            1 // Dealer busts - player wins automatically
        } else if player_value > dealer_value {
            2 // Player has higher value without busting
        } else if dealer_value > player_value {
            3 // Dealer has higher value without busting
        } else {
            4 // Equal values - push (tie)
        };

        result.reveal()
    }
}



================================================
FILE: blackjack/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

import * as anchor from "@coral-xyz/anchor";

module.exports = async function (provider: anchor.AnchorProvider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};



================================================
FILE: blackjack/programs/blackjack/Cargo.toml
================================================
[package]
name = "blackjack"
version = "0.1.0"
description = "Created with Arcium & Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "blackjack"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { version = "0.31.1", features = ["init-if-needed"] }

arcium-client = { version = "0.3.0", default-features = false }
arcium-macros = { version = "0.3.0" }
arcium-anchor = { version = "0.3.0" }



================================================
FILE: blackjack/programs/blackjack/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []



================================================
FILE: blackjack/programs/blackjack/src/lib.rs
================================================
use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;
use arcium_client::idl::arcium::types::CallbackAccount;

const COMP_DEF_OFFSET_SHUFFLE_AND_DEAL_CARDS: u32 = comp_def_offset("shuffle_and_deal_cards");
const COMP_DEF_OFFSET_PLAYER_HIT: u32 = comp_def_offset("player_hit");
const COMP_DEF_OFFSET_PLAYER_DOUBLE_DOWN: u32 = comp_def_offset("player_double_down");
const COMP_DEF_OFFSET_PLAYER_STAND: u32 = comp_def_offset("player_stand");
const COMP_DEF_OFFSET_DEALER_PLAY: u32 = comp_def_offset("dealer_play");
const COMP_DEF_OFFSET_RESOLVE_GAME: u32 = comp_def_offset("resolve_game");

declare_id!("DQxanaqqWcTYvVhrKbeoY6q52NrGksWBL6vSbuVipnS7");

#[arcium_program]
pub mod blackjack {
    use super::*;

    /// Initializes the computation definition for shuffling and dealing cards.
    /// This sets up the MPC environment for the initial deck shuffle and card dealing operation.
    pub fn init_shuffle_and_deal_cards_comp_def(
        ctx: Context<InitShuffleAndDealCardsCompDef>,
    ) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    /// Creates a new blackjack game session and initiates the deck shuffle.
    ///
    /// This function sets up a new game account with initial state and triggers the MPC computation
    /// to shuffle a standard 52-card deck and deal the opening hands (2 cards each to player and dealer).
    /// The actual shuffling and dealing happens confidentially within the Arcium network.
    ///
    /// # Arguments
    /// * `game_id` - Unique identifier for this game session
    /// * `mxe_nonce` - Cryptographic nonce for MXE operations  
    /// * `client_pubkey` - Player's encryption public key for receiving encrypted cards
    /// * `client_nonce` - Player's cryptographic nonce for encryption operations
    pub fn initialize_blackjack_game(
        ctx: Context<InitializeBlackjackGame>,
        computation_offset: u64,
        game_id: u64,
        mxe_nonce: u128,
        mxe_again_nonce: u128,
        client_pubkey: [u8; 32],
        client_nonce: u128,
        client_again_nonce: u128,
    ) -> Result<()> {
        // Initialize the blackjack game account
        let blackjack_game = &mut ctx.accounts.blackjack_game;
        blackjack_game.bump = ctx.bumps.blackjack_game;
        blackjack_game.game_id = game_id;
        blackjack_game.player_pubkey = ctx.accounts.payer.key();
        blackjack_game.player_hand = [0; 32];
        blackjack_game.dealer_hand = [0; 32];
        blackjack_game.deck_nonce = 0;
        blackjack_game.client_nonce = 0;
        blackjack_game.dealer_nonce = 0;
        blackjack_game.player_enc_pubkey = client_pubkey;
        blackjack_game.game_state = GameState::Initial;
        blackjack_game.player_hand_size = 0;
        blackjack_game.dealer_hand_size = 0;

        // Queue the shuffle and deal cards computation
        let args = vec![
            Argument::PlaintextU128(mxe_nonce),
            Argument::PlaintextU128(mxe_again_nonce),
            Argument::ArcisPubkey(client_pubkey),
            Argument::PlaintextU128(client_nonce),
            Argument::ArcisPubkey(client_pubkey),
            Argument::PlaintextU128(client_again_nonce),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![ShuffleAndDealCardsCallback::callback_ix(&[
                CallbackAccount {
                    pubkey: ctx.accounts.blackjack_game.key(),
                    is_writable: true,
                },
            ])],
        )?;
        Ok(())
    }

    /// Handles the result of the shuffle and deal cards MPC computation.
    ///
    /// This callback processes the shuffled deck and dealt cards from the MPC computation.
    /// It updates the game state with the new deck, initial hands, and sets the game to PlayerTurn.
    /// The player receives their encrypted hand while the dealer gets one face-up card visible to the player.
    #[arcium_callback(encrypted_ix = "shuffle_and_deal_cards")]
    pub fn shuffle_and_deal_cards_callback(
        ctx: Context<ShuffleAndDealCardsCallback>,
        output: ComputationOutputs<ShuffleAndDealCardsOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(ShuffleAndDealCardsOutput {
                field_0:
                    ShuffleAndDealCardsOutputStruct0 {
                        field_0: deck,
                        field_1: dealer_hand,
                        field_2: player_hand,
                        field_3: dealer_face_up_card,
                    },
            }) => (deck, dealer_hand, player_hand, dealer_face_up_card),
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        let deck_nonce = o.0.nonce;

        let deck: [[u8; 32]; 3] = o.0.ciphertexts;

        let dealer_nonce = o.1.nonce;

        let dealer_hand: [u8; 32] = o.1.ciphertexts[0];

        let client_pubkey: [u8; 32] = o.2.encryption_key;

        let client_nonce = o.2.nonce;

        let player_hand: [u8; 32] = o.2.ciphertexts[0];

        let dealer_client_pubkey: [u8; 32] = o.3.encryption_key;

        let dealer_client_nonce = o.3.nonce;

        let dealer_face_up_card: [u8; 32] = o.3.ciphertexts[0];

        // Update the blackjack game account
        let blackjack_game = &mut ctx.accounts.blackjack_game;
        blackjack_game.deck = deck;
        blackjack_game.deck_nonce = deck_nonce;
        blackjack_game.client_nonce = client_nonce;
        blackjack_game.dealer_nonce = dealer_nonce;
        blackjack_game.player_enc_pubkey = client_pubkey;
        blackjack_game.game_state = GameState::PlayerTurn; // It is now the player's turn

        require!(
            dealer_client_pubkey == blackjack_game.player_enc_pubkey,
            ErrorCode::InvalidDealerClientPubkey
        );

        // Initialize player hand with first two cards
        blackjack_game.player_hand = player_hand;
        // Initialize dealer hand with face up card and face down card
        blackjack_game.dealer_hand = dealer_hand;
        blackjack_game.player_hand_size = 2;
        blackjack_game.dealer_hand_size = 2;

        emit!(CardsShuffledAndDealtEvent {
            client_nonce,
            dealer_client_nonce,
            player_hand,
            dealer_face_up_card,
            game_id: blackjack_game.game_id,
        });
        Ok(())
    }
    pub fn init_player_hit_comp_def(ctx: Context<InitPlayerHitCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    /// Allows the player to request an additional card (hit).
    ///
    /// This triggers an MPC computation that draws the next card from the shuffled deck
    /// and adds it to the player's hand. The computation also checks if the player busts (exceeds 21)
    /// and returns this information while keeping the actual card values encrypted.
    pub fn player_hit(
        ctx: Context<PlayerHit>,
        computation_offset: u64,
        _game_id: u64,
    ) -> Result<()> {
        require!(
            ctx.accounts.blackjack_game.game_state == GameState::PlayerTurn,
            ErrorCode::InvalidGameState
        );
        require!(
            !ctx.accounts.blackjack_game.player_has_stood,
            ErrorCode::InvalidMove
        );

        let args = vec![
            // Deck
            Argument::PlaintextU128(ctx.accounts.blackjack_game.deck_nonce),
            Argument::Account(ctx.accounts.blackjack_game.key(), 8, 32 * 3),
            // Player hand
            Argument::ArcisPubkey(ctx.accounts.blackjack_game.player_enc_pubkey),
            Argument::PlaintextU128(ctx.accounts.blackjack_game.client_nonce),
            Argument::Account(ctx.accounts.blackjack_game.key(), 8 + 32 * 3, 32),
            // Player hand size
            Argument::PlaintextU8(ctx.accounts.blackjack_game.player_hand_size),
            // Dealer hand size
            Argument::PlaintextU8(ctx.accounts.blackjack_game.dealer_hand_size),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![PlayerHitCallback::callback_ix(&[CallbackAccount {
                pubkey: ctx.accounts.blackjack_game.key(),
                is_writable: true,
            }])],
        )?;
        Ok(())
    }

    #[arcium_callback(encrypted_ix = "player_hit")]
    pub fn player_hit_callback(
        ctx: Context<PlayerHitCallback>,
        output: ComputationOutputs<PlayerHitOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(PlayerHitOutput {
                field_0:
                    PlayerHitOutputStruct0 {
                        field_0: player_hand,
                        field_1: is_bust,
                    },
            }) => (player_hand, is_bust),
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        let client_nonce = o.0.nonce;

        let player_hand: [u8; 32] = o.0.ciphertexts[0];

        let is_bust: bool = o.1;

        let blackjack_game = &mut ctx.accounts.blackjack_game;
        blackjack_game.player_hand = player_hand;
        blackjack_game.client_nonce = client_nonce;

        if is_bust {
            blackjack_game.game_state = GameState::DealerTurn;
            emit!(PlayerBustEvent {
                client_nonce,
                game_id: blackjack_game.game_id,
            });
        } else {
            blackjack_game.game_state = GameState::PlayerTurn;
            emit!(PlayerHitEvent {
                player_hand,
                client_nonce,
                game_id: blackjack_game.game_id,
            });
            blackjack_game.player_hand_size += 1;
        }

        Ok(())
    }

    pub fn init_player_double_down_comp_def(
        ctx: Context<InitPlayerDoubleDownCompDef>,
    ) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    pub fn player_double_down(
        ctx: Context<PlayerDoubleDown>,
        computation_offset: u64,
        _game_id: u64,
    ) -> Result<()> {
        require!(
            ctx.accounts.blackjack_game.game_state == GameState::PlayerTurn,
            ErrorCode::InvalidGameState
        );
        require!(
            !ctx.accounts.blackjack_game.player_has_stood,
            ErrorCode::InvalidMove
        );

        let args = vec![
            // Deck
            Argument::PlaintextU128(ctx.accounts.blackjack_game.deck_nonce),
            Argument::Account(ctx.accounts.blackjack_game.key(), 8, 32 * 3),
            // Player hand
            Argument::ArcisPubkey(ctx.accounts.blackjack_game.player_enc_pubkey),
            Argument::PlaintextU128(ctx.accounts.blackjack_game.client_nonce),
            Argument::Account(ctx.accounts.blackjack_game.key(), 8 + 32 * 3, 32),
            // Player hand size
            Argument::PlaintextU8(ctx.accounts.blackjack_game.player_hand_size),
            // Dealer hand size
            Argument::PlaintextU8(ctx.accounts.blackjack_game.dealer_hand_size),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![PlayerDoubleDownCallback::callback_ix(&[CallbackAccount {
                pubkey: ctx.accounts.blackjack_game.key(),
                is_writable: true,
            }])],
        )?;
        Ok(())
    }

    #[arcium_callback(encrypted_ix = "player_double_down")]
    pub fn player_double_down_callback(
        ctx: Context<PlayerDoubleDownCallback>,
        output: ComputationOutputs<PlayerDoubleDownOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(PlayerDoubleDownOutput {
                field_0:
                    PlayerDoubleDownOutputStruct0 {
                        field_0: player_hand,
                        field_1: is_bust,
                    },
            }) => (player_hand, is_bust),
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        let client_nonce = o.0.nonce;

        let player_hand: [u8; 32] = o.0.ciphertexts[0];

        let is_bust: bool = o.1;

        let blackjack_game = &mut ctx.accounts.blackjack_game;
        blackjack_game.player_hand = player_hand;
        blackjack_game.client_nonce = client_nonce;
        blackjack_game.player_has_stood = true;

        if is_bust {
            blackjack_game.game_state = GameState::DealerTurn;
            emit!(PlayerBustEvent {
                client_nonce,
                game_id: blackjack_game.game_id,
            });
        } else {
            blackjack_game.game_state = GameState::DealerTurn;
            emit!(PlayerDoubleDownEvent {
                player_hand,
                client_nonce,
                game_id: blackjack_game.game_id,
            });
        }

        Ok(())
    }

    pub fn init_player_stand_comp_def(ctx: Context<InitPlayerStandCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    pub fn player_stand(
        ctx: Context<PlayerStand>,
        computation_offset: u64,
        _game_id: u64,
    ) -> Result<()> {
        require!(
            ctx.accounts.blackjack_game.game_state == GameState::PlayerTurn,
            ErrorCode::InvalidGameState
        );
        require!(
            !ctx.accounts.blackjack_game.player_has_stood,
            ErrorCode::InvalidMove
        );

        let args = vec![
            // Player hand
            Argument::ArcisPubkey(ctx.accounts.blackjack_game.player_enc_pubkey),
            Argument::PlaintextU128(ctx.accounts.blackjack_game.client_nonce),
            Argument::Account(ctx.accounts.blackjack_game.key(), 8 + 32 * 3, 32),
            // Player hand size
            Argument::PlaintextU8(ctx.accounts.blackjack_game.player_hand_size),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![PlayerStandCallback::callback_ix(&[CallbackAccount {
                pubkey: ctx.accounts.blackjack_game.key(),
                is_writable: true,
            }])],
        )?;
        Ok(())
    }

    #[arcium_callback(encrypted_ix = "player_stand")]
    pub fn player_stand_callback(
        ctx: Context<PlayerStandCallback>,
        output: ComputationOutputs<PlayerStandOutput>,
    ) -> Result<()> {
        let is_bust = match output {
            ComputationOutputs::Success(PlayerStandOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        let blackjack_game = &mut ctx.accounts.blackjack_game;
        blackjack_game.player_has_stood = true;

        if is_bust {
            // This should never happen
            blackjack_game.game_state = GameState::PlayerTurn;
            emit!(PlayerBustEvent {
                client_nonce: blackjack_game.client_nonce,
                game_id: blackjack_game.game_id,
            });
        } else {
            blackjack_game.game_state = GameState::DealerTurn;
            emit!(PlayerStandEvent {
                is_bust,
                game_id: blackjack_game.game_id
            });
        }

        Ok(())
    }

    pub fn init_dealer_play_comp_def(ctx: Context<InitDealerPlayCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    pub fn dealer_play(
        ctx: Context<DealerPlay>,
        computation_offset: u64,
        _game_id: u64,
        nonce: u128,
    ) -> Result<()> {
        require!(
            ctx.accounts.blackjack_game.game_state == GameState::DealerTurn,
            ErrorCode::InvalidGameState
        );

        let args = vec![
            // Deck
            Argument::PlaintextU128(ctx.accounts.blackjack_game.deck_nonce),
            Argument::Account(ctx.accounts.blackjack_game.key(), 8, 32 * 3),
            // Dealer hand
            Argument::PlaintextU128(ctx.accounts.blackjack_game.dealer_nonce),
            Argument::Account(ctx.accounts.blackjack_game.key(), 8 + 32 * 3 + 32, 32),
            // Client nonce
            Argument::ArcisPubkey(ctx.accounts.blackjack_game.player_enc_pubkey),
            Argument::PlaintextU128(nonce),
            // Player hand size
            Argument::PlaintextU8(ctx.accounts.blackjack_game.player_hand_size),
            // Dealer hand size
            Argument::PlaintextU8(ctx.accounts.blackjack_game.dealer_hand_size),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![DealerPlayCallback::callback_ix(&[CallbackAccount {
                pubkey: ctx.accounts.blackjack_game.key(),
                is_writable: true,
            }])],
        )?;
        Ok(())
    }

    #[arcium_callback(encrypted_ix = "dealer_play")]
    pub fn dealer_play_callback(
        ctx: Context<DealerPlayCallback>,
        output: ComputationOutputs<DealerPlayOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(DealerPlayOutput {
                field_0:
                    DealerPlayOutputStruct0 {
                        field_0: dealer_hand,
                        field_1: dealer_client_hand,
                        field_2: dealer_hand_size,
                    },
            }) => (dealer_hand, dealer_client_hand, dealer_hand_size),
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        let dealer_nonce = o.0.nonce;
        let dealer_hand = o.0.ciphertexts[0];
        let dealer_client_hand = o.1.ciphertexts[0];
        let dealer_hand_size = o.2;
        let client_nonce = o.1.nonce;

        let blackjack_game = &mut ctx.accounts.blackjack_game;
        blackjack_game.dealer_hand = dealer_hand;
        blackjack_game.dealer_nonce = dealer_nonce;
        blackjack_game.dealer_hand_size = dealer_hand_size;
        blackjack_game.game_state = GameState::Resolving;

        emit!(DealerPlayEvent {
            dealer_hand: dealer_client_hand,
            dealer_hand_size,
            client_nonce,
            game_id: ctx.accounts.blackjack_game.game_id,
        });

        Ok(())
    }

    pub fn init_resolve_game_comp_def(ctx: Context<InitResolveGameCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    pub fn resolve_game(
        ctx: Context<ResolveGame>,
        computation_offset: u64,
        _game_id: u64,
    ) -> Result<()> {
        require!(
            ctx.accounts.blackjack_game.game_state == GameState::Resolving,
            ErrorCode::InvalidGameState
        );

        let args = vec![
            // Player hand
            Argument::ArcisPubkey(ctx.accounts.blackjack_game.player_enc_pubkey),
            Argument::PlaintextU128(ctx.accounts.blackjack_game.client_nonce),
            Argument::Account(ctx.accounts.blackjack_game.key(), 8 + 32 * 3, 32),
            // Dealer hand
            Argument::PlaintextU128(ctx.accounts.blackjack_game.dealer_nonce),
            Argument::Account(ctx.accounts.blackjack_game.key(), 8 + 32 * 3 + 32, 32),
            // Player hand size
            Argument::PlaintextU8(ctx.accounts.blackjack_game.player_hand_size),
            // Dealer hand size
            Argument::PlaintextU8(ctx.accounts.blackjack_game.dealer_hand_size),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![ResolveGameCallback::callback_ix(&[CallbackAccount {
                pubkey: ctx.accounts.blackjack_game.key(),
                is_writable: true,
            }])],
        )?;
        Ok(())
    }

    #[arcium_callback(encrypted_ix = "resolve_game")]
    pub fn resolve_game_callback(
        ctx: Context<ResolveGameCallback>,
        output: ComputationOutputs<ResolveGameOutput>,
    ) -> Result<()> {
        let result = match output {
            ComputationOutputs::Success(ResolveGameOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        if result == 0 {
            // Player busts (dealer wins)
            emit!(ResultEvent {
                winner: "Dealer".to_string(),
                game_id: ctx.accounts.blackjack_game.game_id,
            });
        } else if result == 1 {
            // Dealer busts (player wins)
            emit!(ResultEvent {
                winner: "Player".to_string(),
                game_id: ctx.accounts.blackjack_game.game_id,
            });
        } else if result == 2 {
            // Player wins
            emit!(ResultEvent {
                winner: "Player".to_string(),
                game_id: ctx.accounts.blackjack_game.game_id,
            });
        } else if result == 3 {
            // Dealer wins
            emit!(ResultEvent {
                winner: "Dealer".to_string(),
                game_id: ctx.accounts.blackjack_game.game_id,
            });
        } else {
            // Push (tie)
            emit!(ResultEvent {
                winner: "Tie".to_string(),
                game_id: ctx.accounts.blackjack_game.game_id,
            });
        }

        let blackjack_game = &mut ctx.accounts.blackjack_game;
        blackjack_game.game_state = GameState::Resolved;

        Ok(())
    }
}

#[queue_computation_accounts("shuffle_and_deal_cards", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, game_id: u64)]
pub struct InitializeBlackjackGame<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program.
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program.
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_SHUFFLE_AND_DEAL_CARDS)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        init,
        payer = payer,
        space = 8 + BlackjackGame::INIT_SPACE,
        seeds = [b"blackjack_game".as_ref(), game_id.to_le_bytes().as_ref()],
        bump,
    )]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[callback_accounts("shuffle_and_deal_cards")]
#[derive(Accounts)]
pub struct ShuffleAndDealCardsCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_SHUFFLE_AND_DEAL_CARDS)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    #[account(mut)]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[init_computation_definition_accounts("shuffle_and_deal_cards", payer)]
#[derive(Accounts)]
pub struct InitShuffleAndDealCardsCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[queue_computation_accounts("player_hit", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, _game_id: u64)]
pub struct PlayerHit<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program.
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program.
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_PLAYER_HIT)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        mut,
        seeds = [b"blackjack_game".as_ref(), _game_id.to_le_bytes().as_ref()],
        bump = blackjack_game.bump,
    )]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[callback_accounts("player_hit")]
#[derive(Accounts)]
pub struct PlayerHitCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_PLAYER_HIT)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    #[account(mut)]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[init_computation_definition_accounts("player_hit", payer)]
#[derive(Accounts)]
pub struct InitPlayerHitCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[queue_computation_accounts("player_double_down", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, _game_id: u64)]
pub struct PlayerDoubleDown<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program.
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program.
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_PLAYER_DOUBLE_DOWN)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        mut,
        seeds = [b"blackjack_game".as_ref(), _game_id.to_le_bytes().as_ref()],
        bump = blackjack_game.bump,
    )]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[callback_accounts("player_double_down")]
#[derive(Accounts)]
pub struct PlayerDoubleDownCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_PLAYER_DOUBLE_DOWN)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    #[account(mut)]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[init_computation_definition_accounts("player_double_down", payer)]
#[derive(Accounts)]
pub struct InitPlayerDoubleDownCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[queue_computation_accounts("player_stand", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, _game_id: u64)]
pub struct PlayerStand<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program.
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program.
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_PLAYER_STAND)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        mut,
        seeds = [b"blackjack_game".as_ref(), _game_id.to_le_bytes().as_ref()],
        bump = blackjack_game.bump,
    )]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[callback_accounts("player_stand")]
#[derive(Accounts)]
pub struct PlayerStandCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_PLAYER_STAND)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    #[account(mut)]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[init_computation_definition_accounts("player_stand", payer)]
#[derive(Accounts)]
pub struct InitPlayerStandCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[queue_computation_accounts("dealer_play", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, _game_id: u64)]
pub struct DealerPlay<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program.
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program.
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_DEALER_PLAY)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        mut,
        seeds = [b"blackjack_game".as_ref(), _game_id.to_le_bytes().as_ref()],
        bump = blackjack_game.bump,
    )]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[callback_accounts("dealer_play")]
#[derive(Accounts)]
pub struct DealerPlayCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_DEALER_PLAY)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    #[account(mut)]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[init_computation_definition_accounts("dealer_play", payer)]
#[derive(Accounts)]
pub struct InitDealerPlayCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[queue_computation_accounts("resolve_game", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, _game_id: u64)]
pub struct ResolveGame<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program.
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program.
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_RESOLVE_GAME)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        mut,
        seeds = [b"blackjack_game".as_ref(), _game_id.to_le_bytes().as_ref()],
        bump = blackjack_game.bump,
    )]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[callback_accounts("resolve_game")]
#[derive(Accounts)]
pub struct ResolveGameCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_RESOLVE_GAME)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    #[account(mut)]
    pub blackjack_game: Account<'info, BlackjackGame>,
}

#[init_computation_definition_accounts("resolve_game", payer)]
#[derive(Accounts)]
pub struct InitResolveGameCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

/// Represents a single blackjack game session.
///
/// This account stores all the game state including encrypted hands, deck information,
/// and game progress. The deck is stored as three 32-byte encrypted chunks that together
/// represent all 52 cards in shuffled order. Hands are stored encrypted and only
/// decryptable by their respective owners (player) or the MPC network (dealer).
#[account]
#[derive(InitSpace)]
pub struct BlackjackGame {
    /// Encrypted deck split into 3 chunks for storage efficiency
    pub deck: [[u8; 32]; 3],
    /// Player's encrypted hand (only player can decrypt)
    pub player_hand: [u8; 32],
    /// Dealer's encrypted hand (handled by MPC)
    pub dealer_hand: [u8; 32],
    /// Cryptographic nonce for deck encryption
    pub deck_nonce: u128,
    /// Cryptographic nonce for player's hand encryption  
    pub client_nonce: u128,
    /// Cryptographic nonce for dealer's hand encryption
    pub dealer_nonce: u128,
    /// Unique identifier for this game session
    pub game_id: u64,
    /// Solana public key of the player
    pub player_pubkey: Pubkey,
    /// Player's encryption public key for MPC operations
    pub player_enc_pubkey: [u8; 32],
    /// PDA bump seed
    pub bump: u8,
    /// Current state of the game (initial, player turn, dealer turn, etc.)
    pub game_state: GameState,
    /// Number of cards currently in player's hand
    pub player_hand_size: u8,
    /// Number of cards currently in dealer's hand
    pub dealer_hand_size: u8,
    /// Whether the player has chosen to stand
    pub player_has_stood: bool,
    /// Final result of the game once resolved
    pub game_result: u8,
}

#[repr(u8)]
#[derive(InitSpace, AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Debug)]
pub enum GameState {
    Initial = 0,
    PlayerTurn = 1,
    DealerTurn = 2,
    Resolving = 3,
    Resolved = 4,
}

#[event]
pub struct CardsShuffledAndDealtEvent {
    pub player_hand: [u8; 32],
    pub dealer_face_up_card: [u8; 32],
    pub client_nonce: u128,
    pub dealer_client_nonce: u128,
    pub game_id: u64,
}

#[event]
pub struct PlayerHitEvent {
    pub player_hand: [u8; 32],
    pub client_nonce: u128,
    pub game_id: u64,
}

#[event]
pub struct PlayerDoubleDownEvent {
    pub player_hand: [u8; 32],
    pub client_nonce: u128,
    pub game_id: u64,
}

#[event]
pub struct PlayerStandEvent {
    pub is_bust: bool,
    pub game_id: u64,
}

#[event]
pub struct PlayerBustEvent {
    pub client_nonce: u128,
    pub game_id: u64,
}

#[event]
pub struct DealerPlayEvent {
    pub dealer_hand: [u8; 32],
    pub dealer_hand_size: u8,
    pub client_nonce: u128,
    pub game_id: u64,
}

#[event]
pub struct ResultEvent {
    pub winner: String,
    pub game_id: u64,
}

#[error_code]
pub enum ErrorCode {
    #[msg("The computation was aborted")]
    AbortedComputation,
    #[msg("Invalid game state")]
    InvalidGameState,
    #[msg("Invalid move")]
    InvalidMove,
    #[msg("Invalid dealer client pubkey")]
    InvalidDealerClientPubkey,
    #[msg("Cluster not set")]
    ClusterNotSet,
}



================================================
FILE: blackjack/tests/blackjack.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Keypair } from "@solana/web3.js";
import { Blackjack } from "../target/types/blackjack";
import { randomBytes } from "crypto";
import {
  awaitComputationFinalization,
  getArciumEnv,
  getCompDefAccOffset,
  getArciumProgAddress,
  uploadCircuit,
  buildFinalizeCompDefTx,
  RescueCipher,
  deserializeLE,
  getMXEAccAddress,
  getMempoolAccAddress,
  getCompDefAccAddress,
  getExecutingPoolAccAddress,
  x25519,
  getComputationAccAddress,
  getArciumAccountBaseSeed,
  getMXEPublicKey,
} from "@arcium-hq/client";
import * as fs from "fs";
import * as os from "os";
import { expect } from "chai";

// Helper function to calculate Blackjack hand value
function calculateHandValue(cards: number[]): {
  value: number;
  isSoft: boolean;
} {
  let value = 0;
  let aceCount = 0;
  let isSoft = false;

  for (const cardIndex of cards) {
    // Map card index (0-51) to value (Ace=11/1, K/Q/J=10, 2-10=face value)
    const rank = cardIndex % 13; // 0=Ace, 1=2, ..., 9=10, 10=J, 11=Q, 12=K
    if (rank === 0) {
      // Ace
      aceCount++;
      value += 11;
    } else if (rank >= 10) {
      // K, Q, J
      value += 10;
    } else {
      // 2-10
      value += rank + 1;
    }
  }

  // Adjust for Aces if value > 21
  while (value > 21 && aceCount > 0) {
    value -= 10;
    aceCount--;
  }

  // Check if the hand is "soft" (contains an Ace counted as 11)
  isSoft = aceCount > 0 && value <= 21;

  return { value, isSoft };
}

// Updated decompressHand to use hand size
function decompressHand(
  compressedHandValue: bigint,
  handSize: number
): number[] {
  let currentHandValue = compressedHandValue;
  const cards: number[] = [];
  const numCardSlots = 11; // Max possible slots in u128 encoding

  for (let i = 0; i < numCardSlots; i++) {
    const card = currentHandValue % BigInt(64); // Get the last 6 bits
    cards.push(Number(card));
    currentHandValue >>= BigInt(6); // Shift right by 6 bits
  }

  // Return only the actual cards based on handSize, reversing because they were pushed LSB first
  // Filter out potential padding/unused card slots (> 51)
  return cards
    .slice(0, handSize)
    .filter((card) => card <= 51)
    .reverse();
}

describe("Blackjack", () => {
  const owner = readKpJson(`${os.homedir()}/.config/solana/id.json`);

  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.Blackjack as Program<Blackjack>;
  const provider = anchor.getProvider() as anchor.AnchorProvider;

  type Event = anchor.IdlEvents<(typeof program)["idl"]>;
  const awaitEvent = async <E extends keyof Event>(
    eventName: E,
    timeoutMs = 60000
  ): Promise<Event[E]> => {
    let listenerId: number;
    let timeoutId: NodeJS.Timeout;
    const event = await new Promise<Event[E]>((res, rej) => {
      listenerId = program.addEventListener(eventName as any, (event) => {
        if (timeoutId) clearTimeout(timeoutId);
        res(event);
      });
      timeoutId = setTimeout(() => {
        program.removeEventListener(listenerId);
        rej(new Error(`Event ${eventName} timed out after ${timeoutMs}ms`));
      }, timeoutMs);
    });
    await program.removeEventListener(listenerId);
    return event;
  };

  const arciumEnv = getArciumEnv();

  it("Should play a full blackjack game with state awareness", async () => {
    console.log("Owner address:", owner.publicKey.toBase58());

    // --- Initialize Computation Definitions ---
    console.log("Initializing computation definitions...");
    await Promise.all([
      initShuffleAndDealCardsCompDef(program as any, owner, false, false).then(
        (sig) => console.log("Shuffle/Deal CompDef Init Sig:", sig)
      ),
      initPlayerHitCompDef(program as any, owner, false, false).then((sig) =>
        console.log("Player Hit CompDef Init Sig:", sig)
      ),
      initPlayerStandCompDef(program as any, owner, false, false).then((sig) =>
        console.log("Player Stand CompDef Init Sig:", sig)
      ),
      initPlayerDoubleDownCompDef(program as any, owner, false, false).then(
        (sig) => console.log("Player DoubleDown CompDef Init Sig:", sig)
      ),
      initDealerPlayCompDef(program as any, owner, false, false).then((sig) =>
        console.log("Dealer Play CompDef Init Sig:", sig)
      ),
      initResolveGameCompDef(program as any, owner, false, false).then((sig) =>
        console.log("Resolve Game CompDef Init Sig:", sig)
      ),
    ]);
    console.log("All computation definitions initialized.");
    await new Promise((res) => setTimeout(res, 2000));

    // --- Setup Game Cryptography ---
    const privateKey = x25519.utils.randomSecretKey();
    const publicKey = x25519.getPublicKey(privateKey);
    const mxePublicKey = await getMXEPublicKeyWithRetry(
      provider as anchor.AnchorProvider,
      program.programId
    );

    console.log("MXE x25519 pubkey is", mxePublicKey);
    const sharedSecret = x25519.getSharedSecret(privateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);
    const clientNonce = randomBytes(16);
    const dealerClientNonce = randomBytes(16);

    const gameId = BigInt(Math.floor(Math.random() * 1000000));
    const mxeNonce = randomBytes(16);
    const mxeAgainNonce = randomBytes(16);

    const computationOffsetInit = new anchor.BN(randomBytes(8));

    const gameIdBuffer = Buffer.alloc(8);
    gameIdBuffer.writeBigUInt64LE(gameId);

    const blackjackGamePDA = PublicKey.findProgramAddressSync(
      [Buffer.from("blackjack_game"), gameIdBuffer],
      program.programId
    )[0];

    console.log(`Game ID: ${gameId}, PDA: ${blackjackGamePDA.toBase58()}`);

    // --- Initialize Game ---
    const cardsShuffledAndDealtEventPromise = awaitEvent(
      "cardsShuffledAndDealtEvent"
    );
    console.log("Initializing Blackjack game...");

    const initGameSig = await program.methods
      .initializeBlackjackGame(
        computationOffsetInit,
        new anchor.BN(gameId.toString()),
        new anchor.BN(deserializeLE(mxeNonce).toString()),
        new anchor.BN(deserializeLE(mxeAgainNonce).toString()),
        Array.from(publicKey),
        new anchor.BN(deserializeLE(clientNonce).toString()),
        new anchor.BN(deserializeLE(dealerClientNonce).toString())
      )
      .accountsPartial({
        computationAccount: getComputationAccAddress(
          program.programId,
          computationOffsetInit
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(
            getCompDefAccOffset("shuffle_and_deal_cards")
          ).readUInt32LE()
        ),
        blackjackGame: blackjackGamePDA,
      })
      .signers([owner])
      .rpc({ commitment: "confirmed" });
    console.log("Initialize game TX Signature:", initGameSig);

    console.log("Waiting for shuffle/deal computation finalization...");
    const finalizeInitSig = await awaitComputationFinalization(
      provider,
      computationOffsetInit,
      program.programId,
      "confirmed"
    );
    console.log(
      "Shuffle/deal computation finalized. Signature:",
      finalizeInitSig
    );

    const cardsShuffledAndDealtEvent = await cardsShuffledAndDealtEventPromise;
    console.log("Received CardsShuffledAndDealtEvent.");

    let gameState = await program.account.blackjackGame.fetch(blackjackGamePDA);
    expect(gameState.gameState).to.deep.equal({ playerTurn: {} });

    // Decrypt initial hands
    // Convert anchor.BN to Uint8Array (16 bytes for u128) - manual conversion
    let currentClientNonce = Uint8Array.from(
      cardsShuffledAndDealtEvent.clientNonce.toArray("le", 16)
    );

    console.log("Current client nonce:", currentClientNonce);
    let compressedPlayerHand = cipher.decrypt(
      [cardsShuffledAndDealtEvent.playerHand],
      currentClientNonce
    );
    let playerHand = decompressHand(
      compressedPlayerHand[0],
      gameState.playerHandSize
    );
    let { value: playerValue, isSoft: playerIsSoft } =
      calculateHandValue(playerHand);
    console.log(
      `Initial Player Hand: ${playerHand.join(", ")} (Value: ${playerValue}${
        playerIsSoft ? " Soft" : ""
      })`
    );

    let currentDealerClientNonce = Uint8Array.from(
      cardsShuffledAndDealtEvent.dealerClientNonce.toArray("le", 16)
    );
    console.log("Current dealer client nonce:", currentDealerClientNonce);
    let dealerFaceUpCardEncrypted = cipher.decrypt(
      [cardsShuffledAndDealtEvent.dealerFaceUpCard],
      currentDealerClientNonce
    );
    let dealerFaceUpCard = Number(dealerFaceUpCardEncrypted[0] % BigInt(64));
    console.log(`Dealer Face Up Card Index: ${dealerFaceUpCard}`);

    // --- Player's Turn Loop ---
    let playerBusted = false;
    let playerStood = false;

    while (
      gameState.gameState.hasOwnProperty("playerTurn") &&
      !playerBusted &&
      !playerStood
    ) {
      console.log(
        `\nPlayer's Turn. Hand: ${playerHand.join(
          ", "
        )} (Value: ${playerValue}${playerIsSoft ? " Soft" : ""})`
      );

      // Basic Strategy: Hit on 16 or less, Stand on 17 or more. Hit soft 17.
      let action: "hit" | "stand" = "stand";
      if (playerValue < 17 || (playerValue === 17 && playerIsSoft)) {
        action = "hit";
      }

      if (action === "hit") {
        console.log("Player decides to HIT.");
        const playerHitComputationOffset = new anchor.BN(randomBytes(8));
        const playerHitEventPromise = awaitEvent("playerHitEvent");
        const playerBustEventPromise = awaitEvent("playerBustEvent");

        const playerHitSig = await program.methods
          .playerHit(
            playerHitComputationOffset,
            new anchor.BN(gameId.toString())
          )
          .accountsPartial({
            computationAccount: getComputationAccAddress(
              program.programId,
              playerHitComputationOffset
            ),
            clusterAccount: arciumEnv.arciumClusterPubkey,
            mxeAccount: getMXEAccAddress(program.programId),
            mempoolAccount: getMempoolAccAddress(program.programId),
            executingPool: getExecutingPoolAccAddress(program.programId),
            compDefAccount: getCompDefAccAddress(
              program.programId,
              Buffer.from(getCompDefAccOffset("player_hit")).readUInt32LE()
            ),
            blackjackGame: blackjackGamePDA,
            payer: owner.publicKey,
          })
          .signers([owner])
          .rpc({ commitment: "confirmed" });
        console.log("Player Hit TX Signature:", playerHitSig);

        console.log("Waiting for player hit computation finalization...");
        const finalizeHitSig = await awaitComputationFinalization(
          provider,
          playerHitComputationOffset,
          program.programId,
          "confirmed"
        );
        console.log(
          "Player Hit computation finalized. Signature:",
          finalizeHitSig
        );

        try {
          const playerHitEvent = await Promise.race([
            playerHitEventPromise,
            playerBustEventPromise,
          ]);

          gameState = await program.account.blackjackGame.fetch(
            blackjackGamePDA
          );

          if ("playerHand" in playerHitEvent) {
            console.log("Received PlayerHitEvent.");
            currentClientNonce = Uint8Array.from(
              playerHitEvent.clientNonce.toArray("le", 16)
            );
            compressedPlayerHand = cipher.decrypt(
              [playerHitEvent.playerHand],
              currentClientNonce
            );
            playerHand = decompressHand(
              compressedPlayerHand[0],
              gameState.playerHandSize
            );
            ({ value: playerValue, isSoft: playerIsSoft } =
              calculateHandValue(playerHand));
            console.log(
              `New Player Hand: ${playerHand.join(
                ", "
              )} (Value: ${playerValue}${playerIsSoft ? " Soft" : ""})`
            );

            if (playerValue > 21) {
              console.error(
                "ERROR: Bust detected after PlayerHitEvent, expected PlayerBustEvent!"
              );
              playerBusted = true;
            }
          } else {
            console.log("Received PlayerBustEvent.");
            playerBusted = true;
            expect(gameState.gameState).to.deep.equal({ dealerTurn: {} });
            console.log("Player BUSTED!");
          }
        } catch (e) {
          console.error("Error waiting for player hit/bust event:", e);
          throw e;
        }
      } else {
        console.log("Player decides to STAND.");
        const playerStandComputationOffset = new anchor.BN(randomBytes(8));
        const playerStandEventPromise = awaitEvent("playerStandEvent");

        const playerStandSig = await program.methods
          .playerStand(
            playerStandComputationOffset,
            new anchor.BN(gameId.toString())
          )
          .accountsPartial({
            computationAccount: getComputationAccAddress(
              program.programId,
              playerStandComputationOffset
            ),
            clusterAccount: arciumEnv.arciumClusterPubkey,
            mxeAccount: getMXEAccAddress(program.programId),
            mempoolAccount: getMempoolAccAddress(program.programId),
            executingPool: getExecutingPoolAccAddress(program.programId),
            compDefAccount: getCompDefAccAddress(
              program.programId,
              Buffer.from(getCompDefAccOffset("player_stand")).readUInt32LE()
            ),
            blackjackGame: blackjackGamePDA,
            payer: owner.publicKey,
          })
          .signers([owner])
          .rpc({ commitment: "confirmed" });
        console.log("Player Stand TX Signature:", playerStandSig);

        console.log("Waiting for player stand computation finalization...");
        const finalizeStandSig = await awaitComputationFinalization(
          provider,
          playerStandComputationOffset,
          program.programId,
          "confirmed"
        );
        console.log(
          "Player Stand computation finalized. Signature:",
          finalizeStandSig
        );

        const playerStandEvent = await playerStandEventPromise;
        console.log(
          `Received PlayerStandEvent. Is Bust reported? ${playerStandEvent.isBust}`
        );
        expect(playerStandEvent.isBust).to.be.false;

        playerStood = true;
        gameState = await program.account.blackjackGame.fetch(blackjackGamePDA);
        expect(gameState.gameState).to.deep.equal({ dealerTurn: {} });
        console.log("Player stands. Proceeding to Dealer's Turn.");
      }

      if (!playerBusted && !playerStood) {
        await new Promise((res) => setTimeout(res, 1000));
        gameState = await program.account.blackjackGame.fetch(blackjackGamePDA);
      }
    }

    // --- Dealer's Turn ---
    gameState = await program.account.blackjackGame.fetch(blackjackGamePDA);
    if (gameState.gameState.hasOwnProperty("dealerTurn")) {
      console.log("Dealer's Turn...");
      const dealerPlayComputationOffset = new anchor.BN(randomBytes(8));
      const dealerPlayNonce = randomBytes(16);
      const dealerPlayEventPromise = awaitEvent("dealerPlayEvent");

      const dealerPlaySig = await program.methods
        .dealerPlay(
          dealerPlayComputationOffset,
          new anchor.BN(gameId.toString()),
          new anchor.BN(deserializeLE(dealerPlayNonce).toString())
        )
        .accountsPartial({
          computationAccount: getComputationAccAddress(
            program.programId,
            dealerPlayComputationOffset
          ),
          clusterAccount: arciumEnv.arciumClusterPubkey,
          mxeAccount: getMXEAccAddress(program.programId),
          mempoolAccount: getMempoolAccAddress(program.programId),
          executingPool: getExecutingPoolAccAddress(program.programId),
          compDefAccount: getCompDefAccAddress(
            program.programId,
            Buffer.from(getCompDefAccOffset("dealer_play")).readUInt32LE()
          ),
          blackjackGame: blackjackGamePDA,
        })
        .signers([owner])
        .rpc({ commitment: "confirmed" });
      console.log("Dealer Play TX Signature:", dealerPlaySig);

      console.log("Waiting for dealer play computation finalization...");
      const finalizeDealerPlaySig = await awaitComputationFinalization(
        provider,
        dealerPlayComputationOffset,
        program.programId,
        "confirmed"
      );
      console.log(
        "Dealer Play computation finalized. Signature:",
        finalizeDealerPlaySig
      );

      const dealerPlayEvent = await dealerPlayEventPromise;
      console.log("Received DealerPlayEvent.");

      const finalDealerNonce = Uint8Array.from(
        dealerPlayEvent.clientNonce.toArray("le", 16)
      );
      const decryptedDealerHand = cipher.decrypt(
        [dealerPlayEvent.dealerHand],
        finalDealerNonce
      );
      const dealerHand = decompressHand(
        decryptedDealerHand[0],
        dealerPlayEvent.dealerHandSize
      );
      const { value: dealerValue } = calculateHandValue(dealerHand);
      console.log(
        `Final Dealer Hand: ${dealerHand.join(", ")} (Value: ${dealerValue})`
      );
      gameState = await program.account.blackjackGame.fetch(blackjackGamePDA);
      expect(gameState.gameState).to.deep.equal({ resolving: {} });
    } else if (playerBusted) {
      console.log("Player busted, skipping Dealer's Turn.");
      console.log(
        "Manually considering state as Resolving for test flow after player bust."
      );
    }

    gameState = await program.account.blackjackGame.fetch(blackjackGamePDA);
    if (
      gameState.gameState.hasOwnProperty("resolving") ||
      (playerBusted && gameState.gameState.hasOwnProperty("dealerTurn"))
    ) {
      console.log("Resolving Game...");
      const resolveComputationOffset = new anchor.BN(randomBytes(8));
      const resultEventPromise = awaitEvent("resultEvent");

      const resolveSig = await program.methods
        .resolveGame(resolveComputationOffset, new anchor.BN(gameId.toString()))
        .accountsPartial({
          computationAccount: getComputationAccAddress(
            program.programId,
            resolveComputationOffset
          ),
          clusterAccount: arciumEnv.arciumClusterPubkey,
          mxeAccount: getMXEAccAddress(program.programId),
          mempoolAccount: getMempoolAccAddress(program.programId),
          executingPool: getExecutingPoolAccAddress(program.programId),
          compDefAccount: getCompDefAccAddress(
            program.programId,
            Buffer.from(getCompDefAccOffset("resolve_game")).readUInt32LE()
          ),
          blackjackGame: blackjackGamePDA,
          payer: owner.publicKey,
        })
        .signers([owner])
        .rpc({ commitment: "confirmed" });
      console.log("Resolve Game TX Signature:", resolveSig);

      console.log("Waiting for resolve game computation finalization...");
      const finalizeResolveSig = await awaitComputationFinalization(
        provider,
        resolveComputationOffset,
        program.programId,
        "confirmed"
      );
      console.log(
        "Resolve Game computation finalized. Signature:",
        finalizeResolveSig
      );

      const resultEvent = await resultEventPromise;
      console.log("Received ResultEvent.");
      console.log(`GAME OVER! Winner: ${resultEvent.winner}`);
      expect(["Player", "Dealer", "Tie"]).to.include(resultEvent.winner);

      gameState = await program.account.blackjackGame.fetch(blackjackGamePDA);
      expect(gameState.gameState).to.deep.equal({ resolved: {} });
    } else {
      console.warn(
        `Skipping Resolve Game step. Current state: ${
          Object.keys(gameState.gameState)[0]
        }`
      );
    }
  });

  async function initShuffleAndDealCardsCompDef(
    program: Program<Blackjack>,
    owner: Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("shuffle_and_deal_cards");

    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];

    console.log("Shuffle/Deal CompDef PDA:", compDefPDA.toBase58());

    try {
      await program.account.computationDefinitionAccount.fetch(compDefPDA);
      console.log("Shuffle/Deal CompDef already initialized.");
      return "Already Initialized";
    } catch (e) {
      // Not initialized, proceed
    }

    const sig = await program.methods
      .initShuffleAndDealCardsCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .rpc({ commitment: "confirmed" });

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/shuffle_and_deal_cards.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "shuffle_and_deal_cards",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      console.log("Finalizing Shuffle/Deal CompDef...");
      const finalizeTx = await buildFinalizeCompDefTx(
        provider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );
      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
      finalizeTx.sign(owner);
      await provider.sendAndConfirm(finalizeTx, [owner], {
        commitment: "confirmed",
      });
      console.log("Shuffle/Deal CompDef finalized.");
    }
    return sig;
  }

  async function initPlayerHitCompDef(
    program: Program<Blackjack>,
    owner: Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("player_hit");
    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];
    console.log("Player Hit CompDef PDA:", compDefPDA.toBase58());

    try {
      await program.account.computationDefinitionAccount.fetch(compDefPDA);
      console.log("Player Hit CompDef already initialized.");
      return "Already Initialized";
    } catch (e) {
      // Not initialized, proceed
    }

    const sig = await program.methods
      .initPlayerHitCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .rpc({ commitment: "confirmed" });

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/player_hit.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "player_hit",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      console.log("Finalizing Player Hit CompDef...");
      const finalizeTx = await buildFinalizeCompDefTx(
        provider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );
      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
      finalizeTx.sign(owner);
      await provider.sendAndConfirm(finalizeTx, [owner], {
        commitment: "confirmed",
      });
      console.log("Player Hit CompDef finalized.");
    }
    return sig;
  }

  async function initPlayerStandCompDef(
    program: Program<Blackjack>,
    owner: Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("player_stand");
    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];
    console.log("Player Stand CompDef PDA:", compDefPDA.toBase58());

    try {
      await program.account.computationDefinitionAccount.fetch(compDefPDA);
      console.log("Player Stand CompDef already initialized.");
      return "Already Initialized";
    } catch (e) {
      // Not initialized, proceed
    }

    const sig = await program.methods
      .initPlayerStandCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .rpc({ commitment: "confirmed" });

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/player_stand.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "player_stand",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      console.log("Finalizing Player Stand CompDef...");
      const finalizeTx = await buildFinalizeCompDefTx(
        provider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );
      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
      finalizeTx.sign(owner);
      await provider.sendAndConfirm(finalizeTx, [owner], {
        commitment: "confirmed",
      });
      console.log("Player Stand CompDef finalized.");
    }
    return sig;
  }

  async function initPlayerDoubleDownCompDef(
    program: Program<Blackjack>,
    owner: Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("player_double_down");
    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];
    console.log("Player DoubleDown CompDef PDA:", compDefPDA.toBase58());

    try {
      await program.account.computationDefinitionAccount.fetch(compDefPDA);
      console.log("Player DoubleDown CompDef already initialized.");
      return "Already Initialized";
    } catch (e) {
      // Not initialized, proceed
    }

    const sig = await program.methods
      .initPlayerDoubleDownCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .rpc({ commitment: "confirmed" });

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/player_double_down.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "player_double_down",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      console.log("Finalizing Player DoubleDown CompDef...");
      const finalizeTx = await buildFinalizeCompDefTx(
        provider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );
      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
      finalizeTx.sign(owner);
      await provider.sendAndConfirm(finalizeTx, [owner], {
        commitment: "confirmed",
      });
      console.log("Player DoubleDown CompDef finalized.");
    }
    return sig;
  }

  async function initDealerPlayCompDef(
    program: Program<Blackjack>,
    owner: Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("dealer_play");
    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];
    console.log("Dealer Play CompDef PDA:", compDefPDA.toBase58());

    try {
      await program.account.computationDefinitionAccount.fetch(compDefPDA);
      console.log("Dealer Play CompDef already initialized.");
      return "Already Initialized";
    } catch (e) {
      // Not initialized, proceed
    }

    const sig = await program.methods
      .initDealerPlayCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .rpc({ commitment: "confirmed" });

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/dealer_play.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "dealer_play",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      console.log("Finalizing Dealer Play CompDef...");
      const finalizeTx = await buildFinalizeCompDefTx(
        provider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );
      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
      finalizeTx.sign(owner);
      await provider.sendAndConfirm(finalizeTx, [owner], {
        commitment: "confirmed",
      });
      console.log("Dealer Play CompDef finalized.");
    }
    return sig;
  }

  async function initResolveGameCompDef(
    program: Program<Blackjack>,
    owner: Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("resolve_game");
    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];
    console.log("Resolve Game CompDef PDA:", compDefPDA.toBase58());

    try {
      await program.account.computationDefinitionAccount.fetch(compDefPDA);
      console.log("Resolve Game CompDef already initialized.");
      return "Already Initialized";
    } catch (e) {
      // Not initialized, proceed
    }

    const sig = await program.methods
      .initResolveGameCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .rpc({ commitment: "confirmed" });

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/resolve_game.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "resolve_game",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      console.log("Finalizing Resolve Game CompDef...");
      const finalizeTx = await buildFinalizeCompDefTx(
        provider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );
      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
      finalizeTx.sign(owner);
      await provider.sendAndConfirm(finalizeTx, [owner], {
        commitment: "confirmed",
      });
      console.log("Resolve Game CompDef finalized.");
    }
    return sig;
  }
});

async function getMXEPublicKeyWithRetry(
  provider: anchor.AnchorProvider,
  programId: PublicKey,
  maxRetries: number = 10,
  retryDelayMs: number = 500
): Promise<Uint8Array> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const mxePublicKey = await getMXEPublicKey(provider, programId);
      if (mxePublicKey) {
        return mxePublicKey;
      }
    } catch (error) {
      console.log(`Attempt ${attempt} failed to fetch MXE public key:`, error);
    }

    if (attempt < maxRetries) {
      console.log(
        `Retrying in ${retryDelayMs}ms... (attempt ${attempt}/${maxRetries})`
      );
      await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
    }
  }

  throw new Error(
    `Failed to fetch MXE public key after ${maxRetries} attempts`
  );
}

function readKpJson(path: string): anchor.web3.Keypair {
  const file = fs.readFileSync(path);
  return anchor.web3.Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(file.toString()))
  );
}



================================================
FILE: coinflip/README.md
================================================
# Confidential Coin Flip on Solana

This project demonstrates building a confidential on-chain Coin Flip game using Arcium. A player chooses Heads or Tails, and the outcome is determined by a random boolean generated securely within Arcium's confidential computation environment.

## How It Works

### The Challenge of On-Chain Randomness

Generating true, unpredictable randomness on a public blockchain is difficult. On-chain pseudo-random number generators can often be predicted or influenced, making games like Coin Flip potentially unfair if the outcome could be known beforehand.

### Arcium's Solution

Arcium provides confidential computing on Solana, enabling secure random number generation for games:

1.  **Confidential Player Choice**: The player submits their choice (Heads or Tails) encrypted.
2.  **Secure Random Boolean Generation**: The Arcium network generates a random boolean value (representing the coin flip) securely within its confidential computation environment.
3.  **Confidential Computation**: The Arcium network compares the player's encrypted choice against the securely generated random boolean.
4.  **Result Calculation**: The result (win or lose) is computed without revealing the player's choice or the random boolean during the process.
5.  **On-Chain Result**: Only the final outcome (win or lose) is published to the Solana blockchain.

## Game Flow

1.  The player initializes a game session on Solana.
2.  The player submits their encrypted choice (Heads or Tails).
3.  The Solana program triggers the confidential computation on the Arcium network.
4.  Within Arcium's secure environment:
    - A random boolean (the coin flip) is securely generated.
    - The winner is determined based on the player's choice and the generated boolean.
5.  The result (win or lose) is sent back to the Solana program.
6.  The game outcome is recorded on-chain.

## Security Features

- **Player Choice Privacy**: The player's choice (Heads/Tails) is not revealed on-chain or during computation.
- **Unpredictable Outcome**: The coin flip result (random boolean) is generated securely within Arcium's trusted environment, preventing prediction or manipulation.
- **Fair Computation**: The game logic runs securely within Arcium.
- **Verifiable Outcome**: The final result is recorded transparently on the blockchain.

## Getting Started

Refer to the [Arcium documentation](https://docs.arcium.com) for setup instructions.



================================================
FILE: coinflip/Anchor.toml
================================================
[toolchain]
package_manager = "yarn"

[features]
resolution = true
skip-lint = false

[programs.localnet]
coinflip = "AyXE8Npj6s3e74XhUoLu8WmnBGPfUcAjzG8oSyYBbnvP"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"



================================================
FILE: coinflip/Arcium.toml
================================================
[localnet]
# number of nodes in the single cluster of the localnet
nodes = 2
# number of seconds to wait for the localnet to come online
localnet_timeout_secs = 60
# MPC backends this MXE supports (default: ["Cerberus"])
# Supported values: "Cerberus", "Manticore", or both
# Examples: backends = ["Cerberus"] or backends = ["Cerberus", "Manticore"]
backends = ["Cerberus"]
# Required when backends includes "Manticore"
# Each path is copied to corresponding node's artifacts/manticore/computation_folder_N
# Example: manticore_data_folders = ["./data/player-0", "./data/player-1"]
# manticore_data_folders = []


================================================
FILE: coinflip/Cargo.toml
================================================
[workspace]
members = ["programs/*", "encrypted-ixs"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
[patch.crates-io]
proc-macro2 = { git = 'https://github.com/arcium-hq/proc-macro2.git' }


================================================
FILE: coinflip/package.json
================================================
{
  "license": "ISC",
  "scripts": {
    "lint:fix": "prettier */*.js \"*/**/*{.js,.ts}\" -w",
    "lint": "prettier */*.js \"*/**/*{.js,.ts}\" --check"
  },
  "dependencies": {
    "@coral-xyz/anchor": "^0.31.1",
    "@arcium-hq/client": "0.3.0"
  },
  "devDependencies": {
    "chai": "^4.3.4",
    "mocha": "^9.0.3",
    "ts-mocha": "^10.0.0",
    "@types/bn.js": "^5.1.0",
    "@types/chai": "^4.3.0",
    "@types/mocha": "^9.0.0",
    "typescript": "^4.3.5",
    "prettier": "^2.6.2"
  }
}



================================================
FILE: coinflip/rust-toolchain
================================================
1.88.0



================================================
FILE: coinflip/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}



================================================
FILE: coinflip/.prettierignore
================================================
.anchor
.DS_Store
target
node_modules
dist
build
test-ledger



================================================
FILE: coinflip/encrypted-ixs/Cargo.toml
================================================
[package]
name = "encrypted-ixs"
version = "0.1.0"
edition = "2021"

[dependencies]
arcis-imports = { version = "0.3.0" }



================================================
FILE: coinflip/encrypted-ixs/src/lib.rs
================================================
use arcis_imports::*;

#[encrypted]
mod circuits {
    use arcis_imports::*;

    /// Represents the player's choice in the coin flip game.
    pub struct UserChoice {
        pub choice: bool, // Player's choice: true for heads, false for tails
    }

    /// Performs a confidential coin flip and compares it with the player's choice.
    ///
    /// This function generates a cryptographically secure random boolean value within
    /// the MPC environment and compares it with the player's encrypted choice.
    /// The comparison result (win/lose) is revealed while keeping both the player's
    /// choice and the actual coin flip result confidential.
    ///
    /// # Arguments
    /// * `input_ctxt` - Player's encrypted choice (heads or tails)
    ///
    /// # Returns
    /// * `true` if the player's choice matches the coin flip (player wins)
    /// * `false` if the player's choice doesn't match (player loses)
    #[instruction]
    pub fn flip(input_ctxt: Enc<Shared, UserChoice>) -> bool {
        let input = input_ctxt.to_arcis();

        // Generate a cryptographically secure random boolean (the coin flip)
        let toss = ArcisRNG::bool();

        // Compare player's choice with the coin flip result and reveal only the outcome
        (input.choice == toss).reveal()
    }
}



================================================
FILE: coinflip/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

import * as anchor from "@coral-xyz/anchor";

module.exports = async function (provider: anchor.AnchorProvider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};



================================================
FILE: coinflip/programs/coinflip/Cargo.toml
================================================
[package]
name = "coinflip"
version = "0.1.0"
description = "Created with Arcium & Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "coinflip"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { version = "0.31.1", features = ["init-if-needed"] }

arcium-client = { version = "0.3.0", default-features = false }
arcium-macros = { version = "0.3.0" }
arcium-anchor = { version = "0.3.0" }



================================================
FILE: coinflip/programs/coinflip/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []



================================================
FILE: coinflip/programs/coinflip/src/lib.rs
================================================
use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;

const COMP_DEF_OFFSET_FLIP: u32 = comp_def_offset("flip");

declare_id!("AyXE8Npj6s3e74XhUoLu8WmnBGPfUcAjzG8oSyYBbnvP");

#[arcium_program]
pub mod coinflip {
    use super::*;

    /// Initializes the computation definition for the coin flip operation.
    /// This sets up the MPC environment for generating secure randomness and comparing it with the player's choice.
    pub fn init_flip_comp_def(ctx: Context<InitFlipCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    /// Initiates a coin flip game with the player's encrypted choice.
    ///
    /// The player submits their choice (heads or tails) in encrypted form along with their
    /// public key and nonce. The MPC computation will generate a cryptographically secure
    /// random boolean and compare it with the player's choice to determine if they won.
    ///
    /// # Arguments
    /// * `user_choice` - Player's encrypted choice (true for heads, false for tails)
    /// * `pub_key` - Player's public key for encryption operations
    /// * `nonce` - Cryptographic nonce for the encryption
    pub fn flip(
        ctx: Context<Flip>,
        computation_offset: u64,
        user_choice: [u8; 32],
        pub_key: [u8; 32],
        nonce: u128,
    ) -> Result<()> {
        let args = vec![
            Argument::ArcisPubkey(pub_key),
            Argument::PlaintextU128(nonce),
            Argument::EncryptedU8(user_choice),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![FlipCallback::callback_ix(&[])],
        )?;

        Ok(())
    }

    /// Handles the result of the coin flip MPC computation.
    ///
    /// This callback receives the result of comparing the player's choice with the
    /// randomly generated coin flip. The result is a boolean indicating whether
    /// the player won (true) or lost (false).
    #[arcium_callback(encrypted_ix = "flip")]
    pub fn flip_callback(
        ctx: Context<FlipCallback>,
        output: ComputationOutputs<FlipOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(FlipOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        emit!(FlipEvent { result: o });

        Ok(())
    }
}

#[queue_computation_accounts("flip", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64)]
pub struct Flip<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_FLIP)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
}

#[callback_accounts("flip")]
#[derive(Accounts)]
pub struct FlipCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_FLIP)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
}

#[init_computation_definition_accounts("flip", payer)]
#[derive(Accounts)]
pub struct InitFlipCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

/// Event emitted when a coin flip game completes.
#[event]
pub struct FlipEvent {
    /// Whether the player won the coin flip (true = won, false = lost)
    pub result: bool,
}

#[error_code]
pub enum ErrorCode {
    #[msg("The computation was aborted")]
    AbortedComputation,
    #[msg("The cluster is not set")]
    ClusterNotSet,
}



================================================
FILE: coinflip/tests/coinflip.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { Coinflip } from "../target/types/coinflip";
import { randomBytes } from "crypto";
import {
  awaitComputationFinalization,
  getArciumEnv,
  getCompDefAccOffset,
  getArciumAccountBaseSeed,
  getArciumProgAddress,
  uploadCircuit,
  buildFinalizeCompDefTx,
  RescueCipher,
  deserializeLE,
  getMXEAccAddress,
  getMempoolAccAddress,
  getCompDefAccAddress,
  getExecutingPoolAccAddress,
  x25519,
  getComputationAccAddress,
  getMXEPublicKey,
} from "@arcium-hq/client";
import * as fs from "fs";
import * as os from "os";

describe("Coinflip", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.Coinflip as Program<Coinflip>;
  const provider = anchor.getProvider();

  type Event = anchor.IdlEvents<(typeof program)["idl"]>;
  const awaitEvent = async <E extends keyof Event>(eventName: E) => {
    let listenerId: number;
    const event = await new Promise<Event[E]>((res) => {
      listenerId = program.addEventListener(eventName, (event) => {
        res(event);
      });
    });
    await program.removeEventListener(listenerId);

    return event;
  };

  const arciumEnv = getArciumEnv();

  it("flip a coin!", async () => {
    const owner = readKpJson(`${os.homedir()}/.config/solana/id.json`);

    const mxePublicKey = await getMXEPublicKeyWithRetry(
      provider as anchor.AnchorProvider,
      program.programId
    );

    console.log("MXE x25519 pubkey is", mxePublicKey);

    console.log("Initializing flip computation definition");
    const initFlipSig = await initFlipCompDef(program, owner, false, false);
    console.log(
      "Flip computation definition initialized with signature",
      initFlipSig
    );

    const privateKey = x25519.utils.randomSecretKey();
    const publicKey = x25519.getPublicKey(privateKey);
    const sharedSecret = x25519.getSharedSecret(privateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);

    const choice = BigInt(true);
    const plaintext = [choice];

    const nonce = randomBytes(16);
    const ciphertext = cipher.encrypt(plaintext, nonce);

    const flipEventPromise = awaitEvent("flipEvent");

    const computationOffset = new anchor.BN(randomBytes(8), "hex");

    const queueSig = await program.methods
      .flip(
        computationOffset,
        Array.from(ciphertext[0]),
        Array.from(publicKey),
        new anchor.BN(deserializeLE(nonce).toString())
      )
      .accountsPartial({
        computationAccount: getComputationAccAddress(
          program.programId,
          computationOffset
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("flip")).readUInt32LE()
        ),
      })
      .rpc({ skipPreflight: true, commitment: "confirmed" });
    console.log("Queue sig is ", queueSig);

    const finalizeSig = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      computationOffset,
      program.programId,
      "confirmed"
    );
    console.log("Finalize sig is ", finalizeSig);

    const flipEvent = await flipEventPromise;

    if (flipEvent.result) {
      console.log("Congratulations! You won!");
    } else {
      console.log("Better luck next time!");
    }
  });

  async function initFlipCompDef(
    program: Program<Coinflip>,
    owner: anchor.web3.Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("flip");

    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];

    console.log("Comp def pda is ", compDefPDA);

    const sig = await program.methods
      .initFlipCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .signers([owner])
      .rpc({
        commitment: "confirmed",
      });
    console.log("Init flip computation definition transaction", sig);

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/flip.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "flip",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      const finalizeTx = await buildFinalizeCompDefTx(
        provider as anchor.AnchorProvider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );

      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;

      finalizeTx.sign(owner);

      await provider.sendAndConfirm(finalizeTx);
    }
    return sig;
  }
});

async function getMXEPublicKeyWithRetry(
  provider: anchor.AnchorProvider,
  programId: PublicKey,
  maxRetries: number = 10,
  retryDelayMs: number = 500
): Promise<Uint8Array> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const mxePublicKey = await getMXEPublicKey(provider, programId);
      if (mxePublicKey) {
        return mxePublicKey;
      }
    } catch (error) {
      console.log(`Attempt ${attempt} failed to fetch MXE public key:`, error);
    }

    if (attempt < maxRetries) {
      console.log(
        `Retrying in ${retryDelayMs}ms... (attempt ${attempt}/${maxRetries})`
      );
      await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
    }
  }

  throw new Error(
    `Failed to fetch MXE public key after ${maxRetries} attempts`
  );
}

function readKpJson(path: string): anchor.web3.Keypair {
  const file = fs.readFileSync(path);
  return anchor.web3.Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(file.toString()))
  );
}



================================================
FILE: rock_paper_scissors/README.md
================================================
# Variants of Rock, Paper, Scissors

We demonstrate two variants of the classic Rock, Paper, Scissors game implemented using Arcium:

1.  [**Player vs Player (PvP)**](./against-player/): Two players securely commit to their moves (Rock, Paper, or Scissors) without revealing them to each other. The MPC protocol then computes the winner based on the committed moves, revealing only the result.
2.  [**Player vs House (PvE)**](./against-house/): One player plays against the "house". The player commits their move, while the house's move is generated randomly within the MPC computation itself. Again, only the final result (win, lose, or draw) is revealed.



================================================
FILE: rock_paper_scissors/against-house/README.md
================================================
# Confidential Rock Paper Scissors Against the House on Solana

This project demonstrates building a confidential on-chain Rock Paper Scissors game using Arcium, where a player competes against the house. The player's move remains private, and the house's move is generated randomly within Arcium's secure computation environment.

## How It Works

### The Challenge of On-Chain Games

In typical on-chain games, all data is public. For a Player vs. House game, if the house's move generation were predictable or manipulatable on-chain, the game could be unfair.

## Game Flow

1.  The player initializes a game session on Solana.
2.  The player submits their encrypted move.
3.  The Solana program triggers the confidential computation on the Arcium network.
4.  Within Arcium's secure environment:
    - The house's move is randomly generated.
    - The winner is determined based on both moves.
5.  The result (win, lose, draw) is sent back to the Solana program.
6.  The game outcome is recorded on-chain.

## Getting Started

Refer to the [Arcium documentation](https://docs.arcium.com) for setup instructions.



================================================
FILE: rock_paper_scissors/against-house/Anchor.toml
================================================
[toolchain]
package_manager = "yarn"

[features]
resolution = true
skip-lint = false

[programs.localnet]
rock_paper_scissors_against_rng = "GvEcUdVoj6kGH139bD3u29jpuRUyuLCcsZ6rip2CrnPY"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"



================================================
FILE: rock_paper_scissors/against-house/Arcium.toml
================================================
[localnet]
# number of nodes in the single cluster of the localnet
nodes = 2
# number of seconds to wait for the localnet to come online
localnet_timeout_secs = 60
# MPC backends this MXE supports (default: ["Cerberus"])
# Supported values: "Cerberus", "Manticore", or both
# Examples: backends = ["Cerberus"] or backends = ["Cerberus", "Manticore"]
backends = ["Cerberus"]
# Required when backends includes "Manticore"
# Each path is copied to corresponding node's artifacts/manticore/computation_folder_N
# Example: manticore_data_folders = ["./data/player-0", "./data/player-1"]
# manticore_data_folders = []


================================================
FILE: rock_paper_scissors/against-house/Cargo.toml
================================================
[workspace]
members = ["programs/*", "encrypted-ixs"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
[patch.crates-io]
proc-macro2 = { git = 'https://github.com/arcium-hq/proc-macro2.git' }


================================================
FILE: rock_paper_scissors/against-house/package.json
================================================
{
  "license": "ISC",
  "scripts": {
    "lint:fix": "prettier */*.js \"*/**/*{.js,.ts}\" -w",
    "lint": "prettier */*.js \"*/**/*{.js,.ts}\" --check"
  },
  "dependencies": {
    "@coral-xyz/anchor": "^0.31.1",
    "@arcium-hq/client": "0.3.0"
  },
  "devDependencies": {
    "chai": "^4.3.4",
    "mocha": "^9.0.3",
    "ts-mocha": "^10.0.0",
    "@types/bn.js": "^5.1.0",
    "@types/chai": "^4.3.0",
    "@types/mocha": "^9.0.0",
    "typescript": "^4.3.5",
    "prettier": "^2.6.2"
  }
}



================================================
FILE: rock_paper_scissors/against-house/rust-toolchain
================================================
1.88.0



================================================
FILE: rock_paper_scissors/against-house/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}



================================================
FILE: rock_paper_scissors/against-house/.prettierignore
================================================
.anchor
.DS_Store
target
node_modules
dist
build
test-ledger



================================================
FILE: rock_paper_scissors/against-house/encrypted-ixs/Cargo.toml
================================================
[package]
name = "encrypted-ixs"
version = "0.1.0"
edition = "2021"

[dependencies]
arcis-imports = { version = "0.3.0" }



================================================
FILE: rock_paper_scissors/against-house/encrypted-ixs/src/lib.rs
================================================
use arcis_imports::*;

#[encrypted]
mod circuits {
    use arcis_imports::*;

    // Consider 0 - Rock, 1 - Paper, 2 - Scissors
    pub struct PlayerMove {
        player_move: u8,
    }

    #[instruction]
    pub fn play_rps(player_move_ctxt: Enc<Shared, PlayerMove>) -> u8 {
        let player_move = player_move_ctxt.to_arcis();

        let first_bit = ArcisRNG::bool();
        let second_bit = ArcisRNG::bool();

        let house_move = if first_bit {
            if second_bit {
                0
            } else {
                2
            }
        } else if second_bit {
            1
        } else {
            0
        };

        // 0 - tie, 1 - player wins, 2 - house wins, 3 - invalid move
        let result = if player_move.player_move > 2 {
            3
        } else if player_move.player_move == house_move {
            0
        } else if (player_move.player_move == 0 && house_move == 2) || // Rock beats Scissors
                  (player_move.player_move == 1 && house_move == 0) || // Paper beats Rock
                  (player_move.player_move == 2 && house_move == 1)
        // Scissors beats Paper
        {
            1
        } else {
            2
        };

        result.reveal()
    }
}



================================================
FILE: rock_paper_scissors/against-house/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

import * as anchor from "@coral-xyz/anchor";

module.exports = async function (provider: anchor.AnchorProvider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};



================================================
FILE: rock_paper_scissors/against-house/programs/rock_paper_scissors_against_rng/Cargo.toml
================================================
[package]
name = "rock_paper_scissors_against_rng"
version = "0.1.0"
description = "Created with Arcium & Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "rock_paper_scissors_against_rng"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { version = "0.31.1", features = ["init-if-needed"] }

arcium-client = { version = "0.3.0", default-features = false }
arcium-macros = { version = "0.3.0" }
arcium-anchor = { version = "0.3.0" }



================================================
FILE: rock_paper_scissors/against-house/programs/rock_paper_scissors_against_rng/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []



================================================
FILE: rock_paper_scissors/against-house/programs/rock_paper_scissors_against_rng/src/lib.rs
================================================
use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;

const COMP_DEF_OFFSET_PLAY_RPS: u32 = comp_def_offset("play_rps");

declare_id!("GvEcUdVoj6kGH139bD3u29jpuRUyuLCcsZ6rip2CrnPY");

#[arcium_program]
pub mod rock_paper_scissors_against_rng {
    use super::*;

    pub fn init_play_rps_comp_def(ctx: Context<InitPlayRpsCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    pub fn play_rps(
        ctx: Context<PlayRps>,
        computation_offset: u64,
        player_move: [u8; 32],
        pub_key: [u8; 32],
        nonce: u128,
    ) -> Result<()> {
        let args = vec![
            Argument::ArcisPubkey(pub_key),
            Argument::PlaintextU128(nonce),
            Argument::EncryptedU8(player_move),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![PlayRpsCallback::callback_ix(&[])],
        )?;
        Ok(())
    }

    #[arcium_callback(encrypted_ix = "play_rps")]
    pub fn play_rps_callback(
        ctx: Context<PlayRpsCallback>,
        output: ComputationOutputs<PlayRpsOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(PlayRpsOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        let result = match o {
            0 => "Tie".to_string(),
            1 => "Player wins".to_string(),
            2 => "House wins".to_string(),
            _ => "Invalid move".to_string(),
        };

        emit!(PlayRpsEvent { result });
        Ok(())
    }
}

#[queue_computation_accounts("play_rps", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64)]
pub struct PlayRps<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_PLAY_RPS)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
}

#[callback_accounts("play_rps")]
#[derive(Accounts)]
pub struct PlayRpsCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_PLAY_RPS)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
}

#[init_computation_definition_accounts("play_rps", payer)]
#[derive(Accounts)]
pub struct InitPlayRpsCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[event]
pub struct PlayRpsEvent {
    pub result: String,
}

#[error_code]
pub enum ErrorCode {
    #[msg("The computation was aborted")]
    AbortedComputation,
    #[msg("Cluster not set")]
    ClusterNotSet,
}



================================================
FILE: rock_paper_scissors/against-house/tests/rock_paper_scissors_against_rng.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { RockPaperScissorsAgainstRng } from "../target/types/rock_paper_scissors_against_rng";
import { randomBytes } from "crypto";
import {
  awaitComputationFinalization,
  getArciumEnv,
  getCompDefAccOffset,
  getArciumAccountBaseSeed,
  getArciumProgAddress,
  uploadCircuit,
  buildFinalizeCompDefTx,
  RescueCipher,
  deserializeLE,
  getMXEAccAddress,
  getMempoolAccAddress,
  getCompDefAccAddress,
  getExecutingPoolAccAddress,
  x25519,
  getComputationAccAddress,
  getMXEPublicKey,
} from "@arcium-hq/client";
import * as fs from "fs";
import * as os from "os";

describe("RockPaperScissorsAgainstRng", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace
    .RockPaperScissorsAgainstRng as Program<RockPaperScissorsAgainstRng>;
  const provider = anchor.getProvider();

  type Event = anchor.IdlEvents<(typeof program)["idl"]>;
  const awaitEvent = async <E extends keyof Event>(eventName: E) => {
    let listenerId: number;
    const event = await new Promise<Event[E]>((res) => {
      listenerId = program.addEventListener(eventName, (event) => {
        res(event);
      });
    });
    await program.removeEventListener(listenerId);

    return event;
  };

  const arciumEnv = getArciumEnv();

  it("play rps against rng", async () => {
    const owner = readKpJson(`${os.homedir()}/.config/solana/id.json`);

    const mxePublicKey = await getMXEPublicKeyWithRetry(
      provider as anchor.AnchorProvider,
      program.programId
    );

    console.log("MXE x25519 pubkey is", mxePublicKey);

    console.log("Initializing play rps computation definition");
    const initRpsSig = await initPlayRpsCompDef(program, owner, false, false);
    console.log(
      "Play rps computation definition initialized with signature",
      initRpsSig
    );

    const privateKey = x25519.utils.randomSecretKey();
    const publicKey = x25519.getPublicKey(privateKey);
    const sharedSecret = x25519.getSharedSecret(privateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);

    const playerMove = BigInt(2); // 1 = rock, 2 = paper, 3 = scissors
    const plaintext = [playerMove];

    const nonce = randomBytes(16);
    const ciphertext = cipher.encrypt(plaintext, nonce);

    const playRpsEventPromise = awaitEvent("playRpsEvent");

    const computationOffset = new anchor.BN(randomBytes(8), "hex");

    const queueSig = await program.methods
      .playRps(
        computationOffset,
        Array.from(ciphertext[0]),
        Array.from(publicKey),
        new anchor.BN(deserializeLE(nonce).toString())
      )
      .accountsPartial({
        computationAccount: getComputationAccAddress(
          program.programId,
          computationOffset
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("play_rps")).readUInt32LE()
        ),
      })
      .rpc({ commitment: "confirmed" });
    console.log("Queue sig is ", queueSig);

    const finalizeSig = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      computationOffset,
      program.programId,
      "confirmed"
    );
    console.log("Finalize sig is ", finalizeSig);

    const playRpsEvent = await playRpsEventPromise;

    console.log(playRpsEvent.result);
  });

  async function initPlayRpsCompDef(
    program: Program<RockPaperScissorsAgainstRng>,
    owner: anchor.web3.Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("play_rps");

    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];

    console.log("Comp def pda is ", compDefPDA.toBase58());

    const sig = await program.methods
      .initPlayRpsCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .signers([owner])
      .rpc({
        commitment: "confirmed",
      });
    console.log("Init play rps computation definition transaction", sig);

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/play_rps.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "play_rps",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      const finalizeTx = await buildFinalizeCompDefTx(
        provider as anchor.AnchorProvider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );

      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;

      finalizeTx.sign(owner);

      await provider.sendAndConfirm(finalizeTx);
    }
    return sig;
  }
});

async function getMXEPublicKeyWithRetry(
  provider: anchor.AnchorProvider,
  programId: PublicKey,
  maxRetries: number = 10,
  retryDelayMs: number = 500
): Promise<Uint8Array> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const mxePublicKey = await getMXEPublicKey(provider, programId);
      if (mxePublicKey) {
        return mxePublicKey;
      }
    } catch (error) {
      console.log(`Attempt ${attempt} failed to fetch MXE public key:`, error);
    }

    if (attempt < maxRetries) {
      console.log(
        `Retrying in ${retryDelayMs}ms... (attempt ${attempt}/${maxRetries})`
      );
      await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
    }
  }

  throw new Error(
    `Failed to fetch MXE public key after ${maxRetries} attempts`
  );
}

function readKpJson(path: string): anchor.web3.Keypair {
  const file = fs.readFileSync(path);
  return anchor.web3.Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(file.toString()))
  );
}



================================================
FILE: rock_paper_scissors/against-player/README.md
================================================
# Confidential Rock Paper Scissors on Solana

This project demonstrates how to build a confidential on-chain Rock Paper Scissors game using Arcium's confidential computing capabilities. The game ensures that neither player can see the other's move until both moves are committed, preventing any potential cheating.

## How It Works

### The Challenge of On-Chain Games

Traditional on-chain games face a fundamental challenge: all data on the blockchain is public. This means that in a game like Rock Paper Scissors, if one player's move is visible on-chain, the other player could simply wait to see it before making their own move, making the game unfair.

### Arcium's Solution

Arcium solves this by enabling confidential computing on Solana. Here's how it works:

1. **Confidential Move Submission**: Players submit their moves (Rock, Paper, or Scissors) in encrypted form
2. **Off-Chain Computation**: The Arcium network processes the game logic in a confidential environment using dishonest majority MPC
3. **Fair Resolution**: The result is computed without revealing either player's move
4. **On-Chain Result**: Only the final outcome (win, lose, or draw) is published to the blockchain

### Technical Implementation

The project is structured into two main components:

1. **Encrypted Instructions** (`encrypted-ixs/`):
   - Contains the confidential game logic
   - Processes encrypted moves without revealing them
   - Returns only the game result

2. **Solana Program** (`programs/rock_paper_scissors/`):
   - Handles on-chain state management
   - Manages player accounts and game sessions
   - Interfaces with Arcium's confidential computing network

## Game Flow

1. Players initialize a game session
2. Each player submits their move (encrypted)
3. The Arcium network processes the moves confidentially
4. The result is published on-chain
5. Players can claim their winnings based on the outcome

## Security Benefits

- **Move Privacy**: Neither player can see the other's move until both are committed
- **Fair Play**: The game logic runs in a trusted execution environment
- **Transparent Resolution**: While moves are private, the outcome is publicly verifiable
- **No Front-Running**: Players cannot manipulate the game by observing on-chain data

## Getting Started

For detailed setup instructions and API documentation, please refer to the [Arcium documentation](https://docs.arcium.com).



================================================
FILE: rock_paper_scissors/against-player/Anchor.toml
================================================
[toolchain]
package_manager = "yarn"

[features]
resolution = true
skip-lint = false

[programs.localnet]
rock_paper_scissors = "5AQRbcaHCrhGb7VvH35HHaSKzsMJQFHGTfpLbdMfA3Mw"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"



================================================
FILE: rock_paper_scissors/against-player/Arcium.toml
================================================
[localnet]
# number of nodes in the single cluster of the localnet
nodes = 2
# number of seconds to wait for the localnet to come online
localnet_timeout_secs = 60
# MPC backends this MXE supports (default: ["Cerberus"])
# Supported values: "Cerberus", "Manticore", or both
# Examples: backends = ["Cerberus"] or backends = ["Cerberus", "Manticore"]
backends = ["Cerberus"]
# Required when backends includes "Manticore"
# Each path is copied to corresponding node's artifacts/manticore/computation_folder_N
# Example: manticore_data_folders = ["./data/player-0", "./data/player-1"]
# manticore_data_folders = []


================================================
FILE: rock_paper_scissors/against-player/Cargo.toml
================================================
[workspace]
members = ["programs/*", "encrypted-ixs"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
[patch.crates-io]
proc-macro2 = { git = 'https://github.com/arcium-hq/proc-macro2.git' }


================================================
FILE: rock_paper_scissors/against-player/package.json
================================================
{
  "license": "ISC",
  "scripts": {
    "lint:fix": "prettier */*.js \"*/**/*{.js,.ts}\" -w",
    "lint": "prettier */*.js \"*/**/*{.js,.ts}\" --check"
  },
  "dependencies": {
    "@coral-xyz/anchor": "^0.31.1",
    "@arcium-hq/client": "0.3.0"
  },
  "devDependencies": {
    "chai": "^4.3.4",
    "mocha": "^9.0.3",
    "ts-mocha": "^10.0.0",
    "@types/bn.js": "^5.1.0",
    "@types/chai": "^4.3.0",
    "@types/mocha": "^9.0.0",
    "typescript": "^4.3.5",
    "prettier": "^2.6.2"
  }
}



================================================
FILE: rock_paper_scissors/against-player/rust-toolchain
================================================
1.88.0



================================================
FILE: rock_paper_scissors/against-player/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}



================================================
FILE: rock_paper_scissors/against-player/.prettierignore
================================================
.anchor
.DS_Store
target
node_modules
dist
build
test-ledger



================================================
FILE: rock_paper_scissors/against-player/encrypted-ixs/Cargo.toml
================================================
[package]
name = "encrypted-ixs"
version = "0.1.0"
edition = "2021"

[dependencies]
arcis-imports = { version = "0.3.0" }



================================================
FILE: rock_paper_scissors/against-player/encrypted-ixs/src/lib.rs
================================================
use arcis_imports::*;

#[encrypted]
mod circuits {
    use arcis_imports::*;

    // Consider 0 - Rock, 1 - Paper, 2 - Scissors
    pub struct GameMoves {
        player_a_move: u8,
        player_b_move: u8,
    }

    #[instruction]
    pub fn init_game(mxe: Mxe) -> Enc<Mxe, GameMoves> {
        let game_moves = GameMoves {
            player_a_move: 3, // Moves are 0-2, so 3 is invalid
            player_b_move: 3, // Moves are 0-2, so 3 is invalid
        };

        mxe.from_arcis(game_moves)
    }

    pub struct PlayersMove {
        player: u8,
        player_move: u8,
    }

    #[instruction]
    pub fn player_move(
        players_move_ctxt: Enc<Shared, PlayersMove>,
        game_ctxt: Enc<Mxe, GameMoves>,
    ) -> Enc<Mxe, GameMoves> {
        let players_move = players_move_ctxt.to_arcis();
        let mut game_moves = game_ctxt.to_arcis();

        // Check which player is moving, if the player hasn't played their move yet, and the move is valid
        if players_move.player == 0 && game_moves.player_a_move == 3 && players_move.player_move < 3
        {
            game_moves.player_a_move = players_move.player_move;
        } else if players_move.player == 1
            && game_moves.player_b_move == 3
            && players_move.player_move < 3
        {
            game_moves.player_b_move = players_move.player_move;
        }

        game_ctxt.owner.from_arcis(game_moves)
    }

    #[instruction]
    pub fn compare_moves(game_ctxt: Enc<Mxe, GameMoves>) -> u8 {
        let game_moves = game_ctxt.to_arcis();

        // 0 - tie, 1 - player A wins, 2 - player B wins, 3 - invalid move
        let mut result = 3;

        // If moves are the same, it's a tie
        if game_moves.player_a_move == game_moves.player_b_move {
            result = 0;
        } else if (game_moves.player_a_move == 0 && game_moves.player_b_move == 2) || // Rock beats Scissors
                  (game_moves.player_a_move == 1 && game_moves.player_b_move == 0) || // Paper beats Rock
                  (game_moves.player_a_move == 2 && game_moves.player_b_move == 1)
        // Scissors beats Paper
        {
            result = 1; // Player A wins
        } else {
            result = 2; // Player B wins
        }

        // If either player hasn't played their move yet, the result is invalid
        if game_moves.player_a_move == 3 || game_moves.player_b_move == 3 {
            result = 3;
        }

        result.reveal()
    }
}



================================================
FILE: rock_paper_scissors/against-player/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

import * as anchor from "@coral-xyz/anchor";

module.exports = async function (provider: anchor.AnchorProvider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};



================================================
FILE: rock_paper_scissors/against-player/programs/rock_paper_scissors/Cargo.toml
================================================
[package]
name = "rock_paper_scissors"
version = "0.1.0"
description = "Created with Arcium & Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "rock_paper_scissors"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { version = "0.31.1", features = ["init-if-needed"] }

arcium-client = { version = "0.3.0", default-features = false }
arcium-macros = { version = "0.3.0" }
arcium-anchor = { version = "0.3.0" }



================================================
FILE: rock_paper_scissors/against-player/programs/rock_paper_scissors/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []



================================================
FILE: rock_paper_scissors/against-player/programs/rock_paper_scissors/src/lib.rs
================================================
use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;
use arcium_client::idl::arcium::types::CallbackAccount;

const COMP_DEF_OFFSET_INIT_GAME: u32 = comp_def_offset("init_game");
const COMP_DEF_OFFSET_PLAYER_MOVE: u32 = comp_def_offset("player_move");
const COMP_DEF_OFFSET_COMPARE_MOVES: u32 = comp_def_offset("compare_moves");

declare_id!("5AQRbcaHCrhGb7VvH35HHaSKzsMJQFHGTfpLbdMfA3Mw");

#[arcium_program]
pub mod rock_paper_scissors {
    use super::*;

    pub fn init_init_game_comp_def(ctx: Context<InitInitGameCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    pub fn init_game(
        ctx: Context<InitGame>,
        computation_offset: u64,
        id: u64,
        player_a: Pubkey,
        player_b: Pubkey,
        nonce: u128,
    ) -> Result<()> {
        let game = &mut ctx.accounts.rps_game;
        game.id = id;
        game.player_a = player_a;
        game.player_b = player_b;
        game.nonce = nonce;

        let args = vec![Argument::PlaintextU128(nonce)];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![InitGameCallback::callback_ix(&[CallbackAccount {
                pubkey: ctx.accounts.rps_game.key(),
                is_writable: true,
            }])],
        )?;

        Ok(())
    }

    #[arcium_callback(encrypted_ix = "init_game")]
    pub fn init_game_callback(
        ctx: Context<InitGameCallback>,
        output: ComputationOutputs<InitGameOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(InitGameOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        let nonce = o.nonce;

        let moves: [[u8; 32]; 2] = o.ciphertexts;

        let game = &mut ctx.accounts.rps_game;
        game.moves = moves;
        game.nonce = nonce;

        Ok(())
    }

    pub fn init_player_move_comp_def(ctx: Context<InitPlayerMoveCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    pub fn player_move(
        ctx: Context<PlayerMove>,
        computation_offset: u64,
        player_id: [u8; 32],
        player_move: [u8; 32],
        pub_key: [u8; 32],
        nonce: u128,
    ) -> Result<()> {
        require!(
            ctx.accounts.payer.key() == ctx.accounts.rps_game.player_a
                || ctx.accounts.payer.key() == ctx.accounts.rps_game.player_b,
            ErrorCode::NotAuthorized
        );

        let args = vec![
            Argument::ArcisPubkey(pub_key),
            Argument::PlaintextU128(nonce),
            Argument::EncryptedU8(player_id),
            Argument::EncryptedU8(player_move),
            Argument::PlaintextU128(ctx.accounts.rps_game.nonce),
            Argument::Account(ctx.accounts.rps_game.key(), 8, 32 * 2),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![PlayerMoveCallback::callback_ix(&[CallbackAccount {
                pubkey: ctx.accounts.rps_game.key(),
                is_writable: true,
            }])],
        )?;
        Ok(())
    }

    #[arcium_callback(encrypted_ix = "player_move")]
    pub fn player_move_callback(
        ctx: Context<PlayerMoveCallback>,
        output: ComputationOutputs<PlayerMoveOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(PlayerMoveOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        let nonce = o.nonce;

        let moves: [[u8; 32]; 2] = o.ciphertexts;

        let game = &mut ctx.accounts.rps_game;
        game.moves = moves;
        game.nonce = nonce;

        Ok(())
    }

    pub fn init_compare_moves_comp_def(ctx: Context<InitCompareMovesCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    pub fn compare_moves(ctx: Context<CompareMoves>, computation_offset: u64) -> Result<()> {
        let args = vec![
            Argument::PlaintextU128(ctx.accounts.rps_game.nonce),
            Argument::Account(ctx.accounts.rps_game.key(), 8, 32 * 2),
        ];
        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![CompareMovesCallback::callback_ix(&[])],
        )?;
        Ok(())
    }

    #[arcium_callback(encrypted_ix = "compare_moves")]
    pub fn compare_moves_callback(
        ctx: Context<CompareMovesCallback>,
        output: ComputationOutputs<CompareMovesOutput>,
    ) -> Result<()> {
        let result = match output {
            ComputationOutputs::Success(CompareMovesOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        let result_str = match result {
            0 => "Tie",
            1 => "Player A Wins",
            2 => "Player B Wins",
            3 => "Invalid Move",
            _ => "Unknown",
        };

        emit!(CompareMovesEvent {
            result: result_str.to_string(),
        });
        Ok(())
    }
}

#[queue_computation_accounts("init_game", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, id: u64)]
pub struct InitGame<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_INIT_GAME)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(init,
        payer = payer,
        space = 8 + RPSGame::INIT_SPACE,
        seeds = [b"rps_game", id.to_le_bytes().as_ref()],
        bump,
    )]
    pub rps_game: Account<'info, RPSGame>,
}

#[callback_accounts("init_game")]
#[derive(Accounts)]
pub struct InitGameCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_INIT_GAME)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    #[account(mut)]
    pub rps_game: Account<'info, RPSGame>,
}

#[init_computation_definition_accounts("init_game", payer)]
#[derive(Accounts)]
pub struct InitInitGameCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[queue_computation_accounts("player_move", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64)]
pub struct PlayerMove<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_PLAYER_MOVE)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(mut)]
    pub rps_game: Account<'info, RPSGame>,
}

#[callback_accounts("player_move")]
#[derive(Accounts)]
pub struct PlayerMoveCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_PLAYER_MOVE)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    #[account(mut)]
    pub rps_game: Account<'info, RPSGame>,
}

#[init_computation_definition_accounts("player_move", payer)]
#[derive(Accounts)]
pub struct InitPlayerMoveCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[queue_computation_accounts("compare_moves", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64)]
pub struct CompareMoves<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_COMPARE_MOVES)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(mut)]
    pub rps_game: Account<'info, RPSGame>,
}

#[callback_accounts("compare_moves")]
#[derive(Accounts)]
pub struct CompareMovesCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_COMPARE_MOVES)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
}

#[init_computation_definition_accounts("compare_moves", payer)]
#[derive(Accounts)]
pub struct InitCompareMovesCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(InitSpace)]
pub struct RPSGame {
    pub moves: [[u8; 32]; 2],
    pub player_a: Pubkey,
    pub player_b: Pubkey,
    pub nonce: u128,
    pub id: u64,
}

#[event]
pub struct CompareMovesEvent {
    pub result: String,
}

#[error_code]
pub enum ErrorCode {
    #[msg("The computation was aborted")]
    AbortedComputation,
    #[msg("Not authorized")]
    NotAuthorized,
    #[msg("Cluster not set")]
    ClusterNotSet,
}



================================================
FILE: rock_paper_scissors/against-player/tests/rock_paper_scissors.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Keypair } from "@solana/web3.js";
import { RockPaperScissors } from "../target/types/rock_paper_scissors";
import { randomBytes } from "crypto";
import {
  awaitComputationFinalization,
  getArciumEnv,
  getCompDefAccOffset,
  getArciumAccountBaseSeed,
  getArciumProgAddress,
  uploadCircuit,
  buildFinalizeCompDefTx,
  RescueCipher,
  deserializeLE,
  getMXEAccAddress,
  getMempoolAccAddress,
  getCompDefAccAddress,
  getExecutingPoolAccAddress,
  x25519,
  getComputationAccAddress,
  getMXEPublicKey,
} from "@arcium-hq/client";
import * as fs from "fs";
import * as os from "os";
import { expect } from "chai";

describe("RockPaperScissors", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace
    .RockPaperScissors as Program<RockPaperScissors>;
  const provider = anchor.getProvider();

  type Event = anchor.IdlEvents<(typeof program)["idl"]>;
  const awaitEvent = async <E extends keyof Event>(eventName: E) => {
    let listenerId: number;
    const event = await new Promise<Event[E]>((res) => {
      listenerId = program.addEventListener(eventName, (event) => {
        res(event);
      });
    });
    await program.removeEventListener(listenerId);

    return event;
  };

  const arciumEnv = getArciumEnv();

  // Combined test suite for Rock Paper Scissors game
  it("Tests the complete Rock Paper Scissors game flow", async () => {
    const owner = readKpJson(`${os.homedir()}/.config/solana/id.json`);
    const playerA = Keypair.generate();
    const playerB = Keypair.generate();
    const unauthorizedPlayer = Keypair.generate();

    const mxePublicKey = await getMXEPublicKeyWithRetry(
      provider as anchor.AnchorProvider,
      program.programId
    );

    console.log("MXE x25519 pubkey is", mxePublicKey);

    // Step 1: Initialize computation definitions
    console.log("Initializing init_game computation definition");
    const initGameSig = await initInitGameCompDef(program, owner, false, false);
    console.log(
      "Init game computation definition initialized with signature",
      initGameSig
    );

    console.log("Initializing player_move computation definition");
    const playerMoveSig = await initPlayerMoveCompDef(
      program,
      owner,
      false,
      false
    );
    console.log(
      "Player move computation definition initialized with signature",
      playerMoveSig
    );

    console.log("Initializing compare_moves computation definition");
    const compareMovesSig = await initCompareMovesCompDef(
      program,
      owner,
      false,
      false
    );
    console.log(
      "Compare moves computation definition initialized with signature",
      compareMovesSig
    );

    // Step 2: Play a complete game with two players
    console.log("\n--- Playing a complete game with two players ---");

    // Generate encryption keys for Player A
    const playerAPrivateKey = x25519.utils.randomSecretKey();
    const playerAPublicKey = x25519.getPublicKey(playerAPrivateKey);
    const playerASharedSecret = x25519.getSharedSecret(
      playerAPrivateKey,
      mxePublicKey
    );
    const playerACipher = new RescueCipher(playerASharedSecret);

    // Generate encryption keys for Player B
    const playerBPrivateKey = x25519.utils.randomSecretKey();
    const playerBPublicKey = x25519.getPublicKey(playerBPrivateKey);
    const playerBSharedSecret = x25519.getSharedSecret(
      playerBPrivateKey,
      mxePublicKey
    );
    const playerBCipher = new RescueCipher(playerBSharedSecret);

    // Initialize a new game
    const gameId = 1;
    const nonce = randomBytes(16);

    const initComputationOffset = new anchor.BN(randomBytes(8), "hex");

    console.log("Initializing a new game");
    const initGameTx = await program.methods
      .initGame(
        initComputationOffset,
        new anchor.BN(gameId),
        playerA.publicKey,
        playerB.publicKey,
        new anchor.BN(deserializeLE(nonce).toString())
      )
      .accounts({
        computationAccount: getComputationAccAddress(
          program.programId,
          initComputationOffset
        ),
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("init_game")).readUInt32LE()
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
      })
      .signers([owner])
      .rpc({ commitment: "confirmed" });

    console.log("Game initialized with signature:", initGameTx);

    // Wait for initGame computation finalization
    const initGameFinalizeSig = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      initComputationOffset,
      program.programId,
      "confirmed"
    );
    console.log("Init game finalize signature:", initGameFinalizeSig);

    // Airdrop funds to Player A
    console.log("Airdropping funds to Player A");
    const airdropPlayerATx = await provider.connection.requestAirdrop(
      playerA.publicKey,
      2 * anchor.web3.LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction({
      signature: airdropPlayerATx,
      blockhash: (await provider.connection.getLatestBlockhash()).blockhash,
      lastValidBlockHeight: (
        await provider.connection.getLatestBlockhash()
      ).lastValidBlockHeight,
    });
    console.log("Funds airdropped to Player A");

    // Player A makes a move (Rock)
    const playerAMove = 0; // Rock
    const playerAId = 0;
    const playerANonce = randomBytes(16);
    const playerACiphertext = playerACipher.encrypt(
      [BigInt(playerAId), BigInt(playerAMove)],
      playerANonce
    );

    const playerAMoveComputationOffset = new anchor.BN(randomBytes(8), "hex");

    console.log("Player A making a move (Rock)");
    const playerAMoveTx = await program.methods
      .playerMove(
        playerAMoveComputationOffset,
        Array.from(playerACiphertext[0]),
        Array.from(playerACiphertext[1]),
        Array.from(playerAPublicKey),
        new anchor.BN(deserializeLE(playerANonce).toString())
      )
      .accounts({
        payer: playerA.publicKey,
        computationAccount: getComputationAccAddress(
          program.programId,
          playerAMoveComputationOffset
        ),
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("player_move")).readUInt32LE()
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
        rpsGame: PublicKey.findProgramAddressSync(
          [
            Buffer.from("rps_game"),
            new anchor.BN(gameId).toArrayLike(Buffer, "le", 8),
          ],
          program.programId
        )[0],
      })
      .signers([playerA])
      .rpc({ commitment: "confirmed" });

    console.log("Player A move signature:", playerAMoveTx);

    // Wait for player A move computation finalization
    const playerAMoveFinalizeSig = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      playerAMoveComputationOffset,
      program.programId,
      "confirmed"
    );
    console.log("Player A move finalize signature:", playerAMoveFinalizeSig);

    // Airdrop funds to Player B
    console.log("Airdropping funds to Player B");
    const airdropPlayerBTx = await provider.connection.requestAirdrop(
      playerB.publicKey,
      2 * anchor.web3.LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction({
      signature: airdropPlayerBTx,
      blockhash: (await provider.connection.getLatestBlockhash()).blockhash,
      lastValidBlockHeight: (
        await provider.connection.getLatestBlockhash()
      ).lastValidBlockHeight,
    });
    console.log("Funds airdropped to Player B");

    // Player B makes a move (Scissors)
    const playerBMove = 2; // Scissors
    const playerBId = 1;
    const playerBNonce = randomBytes(16);
    const playerBCiphertext = playerBCipher.encrypt(
      [BigInt(playerBId), BigInt(playerBMove)],
      playerBNonce
    );

    const playerBMoveComputationOffset = new anchor.BN(randomBytes(8), "hex");

    console.log("Player B making a move (Scissors)");
    const playerBMoveTx = await program.methods
      .playerMove(
        playerBMoveComputationOffset,
        Array.from(playerBCiphertext[0]),
        Array.from(playerBCiphertext[1]),
        Array.from(playerBPublicKey),
        new anchor.BN(deserializeLE(playerBNonce).toString())
      )
      .accounts({
        computationAccount: getComputationAccAddress(
          program.programId,
          playerBMoveComputationOffset
        ),
        payer: playerB.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("player_move")).readUInt32LE()
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
        rpsGame: PublicKey.findProgramAddressSync(
          [
            Buffer.from("rps_game"),
            new anchor.BN(gameId).toArrayLike(Buffer, "le", 8),
          ],
          program.programId
        )[0],
      })
      .signers([playerB])
      .rpc({ commitment: "confirmed" });

    console.log("Player B move signature:", playerBMoveTx);

    // Wait for player B move computation finalization
    const playerBMoveFinalizeSig = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      playerBMoveComputationOffset,
      program.programId,
      "confirmed"
    );
    console.log("Player B move finalize signature:", playerBMoveFinalizeSig);

    // Compare moves to determine the winner
    const gameEventPromise = awaitEvent("compareMovesEvent");

    const compareComputationOffset = new anchor.BN(randomBytes(8), "hex");

    console.log("Comparing moves");
    const compareTx = await program.methods
      .compareMoves(compareComputationOffset)
      .accounts({
        computationAccount: getComputationAccAddress(
          program.programId,
          compareComputationOffset
        ),
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("compare_moves")).readUInt32LE()
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
        rpsGame: PublicKey.findProgramAddressSync(
          [
            Buffer.from("rps_game"),
            new anchor.BN(gameId).toArrayLike(Buffer, "le", 8),
          ],
          program.programId
        )[0],
      })
      .rpc({ commitment: "confirmed" });

    const finalizeSig = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      compareComputationOffset,
      program.programId,
      "confirmed"
    );
    console.log("Finalize signature:", finalizeSig);

    const gameEvent = await gameEventPromise;
    console.log(`Game result: ${gameEvent.result}`);

    // Verify the result (Rock beats Scissors, so Player A wins)
    expect(gameEvent.result).to.equal("Player A Wins");

    // Step 3: Test unauthorized player trying to make a move
    console.log("\n--- Testing unauthorized player ---");

    // Generate new encryption keys for this test
    const unauthorizedPrivateKey = x25519.utils.randomSecretKey();
    const unauthorizedPublicKey = x25519.getPublicKey(unauthorizedPrivateKey);
    const unauthorizedMxePublicKey = new Uint8Array([
      34, 56, 246, 3, 165, 122, 74, 68, 14, 81, 107, 73, 129, 145, 196, 4, 98,
      253, 120, 15, 235, 108, 37, 198, 124, 111, 38, 1, 210, 143, 72, 87,
    ]);
    const unauthorizedSharedSecret = x25519.getSharedSecret(
      unauthorizedPrivateKey,
      unauthorizedMxePublicKey
    );
    const unauthorizedCipher = new RescueCipher(unauthorizedSharedSecret);

    // Initialize a new game
    const gameId2 = new anchor.BN(Date.now());
    const nonce2 = randomBytes(16);
    const nonceValue2 = new anchor.BN(deserializeLE(nonce2).toString());

    const initComputationOffset2 = new anchor.BN(randomBytes(8), "hex");

    console.log("Initializing a new game");
    const initGameTx2 = await program.methods
      .initGame(
        initComputationOffset2,
        gameId2,
        playerA.publicKey,
        playerB.publicKey,
        nonceValue2
      )
      .accounts({
        computationAccount: getComputationAccAddress(
          program.programId,
          initComputationOffset2
        ),
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("init_game")).readUInt32LE()
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
      })
      .signers([owner])
      .rpc({ commitment: "confirmed" });

    console.log("Game initialized with signature:", initGameTx2);

    // Wait for initGame computation finalization
    const initGameFinalizeSig2 = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      initComputationOffset2,
      program.programId,
      "confirmed"
    );
    console.log("Init game finalize signature:", initGameFinalizeSig2);

    // Airdrop funds to unauthorized player
    console.log("Airdropping funds to unauthorized player");
    const airdropUnauthorizedTx = await provider.connection.requestAirdrop(
      unauthorizedPlayer.publicKey,
      2 * anchor.web3.LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction({
      signature: airdropUnauthorizedTx,
      blockhash: (await provider.connection.getLatestBlockhash()).blockhash,
      lastValidBlockHeight: (
        await provider.connection.getLatestBlockhash()
      ).lastValidBlockHeight,
    });
    console.log("Funds airdropped to unauthorized player");

    // Unauthorized player tries to make a move
    const unauthorizedMove = 1; // Paper
    const unauthorizedNonce = randomBytes(16);
    const unauthorizedCiphertext = unauthorizedCipher.encrypt(
      [BigInt(0), BigInt(unauthorizedMove)],
      unauthorizedNonce
    );

    console.log("Unauthorized player attempting to make a move");
    try {
      const unauthorizedMoveComputationOffset = new anchor.BN(
        randomBytes(8),
        "hex"
      );

      await program.methods
        .playerMove(
          unauthorizedMoveComputationOffset,
          Array.from(unauthorizedCiphertext[0]),
          Array.from(unauthorizedCiphertext[1]),
          Array.from(unauthorizedPublicKey),
          new anchor.BN(deserializeLE(unauthorizedNonce).toString())
        )
        .accounts({
          computationAccount: getComputationAccAddress(
            program.programId,
            unauthorizedMoveComputationOffset
          ),
          payer: unauthorizedPlayer.publicKey,
          mxeAccount: getMXEAccAddress(program.programId),
          mempoolAccount: getMempoolAccAddress(program.programId),
          executingPool: getExecutingPoolAccAddress(program.programId),
          compDefAccount: getCompDefAccAddress(
            program.programId,
            Buffer.from(getCompDefAccOffset("player_move")).readUInt32LE()
          ),
          clusterAccount: arciumEnv.arciumClusterPubkey,
          rpsGame: PublicKey.findProgramAddressSync(
            [Buffer.from("rps_game"), gameId2.toArrayLike(Buffer, "le", 8)],
            program.programId
          )[0],
        })
        .signers([unauthorizedPlayer])
        .rpc({ commitment: "confirmed" });

      // If we get here, the test should fail because unauthorized player should not be able to make a move
      expect.fail("Unauthorized player was able to make a move");
    } catch (error) {
      console.log("Expected error caught:", error.message);
      // Test passes if we catch an error
      expect(error).to.be.an("error");
    }

    // Step 4: Test multiple game scenarios
    console.log("\n--- Testing multiple game scenarios ---");

    // Generate encryption keys for multiple game scenarios
    const scenarioPrivateKey = x25519.utils.randomSecretKey();
    const scenarioPublicKey = x25519.getPublicKey(scenarioPrivateKey);
    const scenarioMxePublicKey = new Uint8Array([
      34, 56, 246, 3, 165, 122, 74, 68, 14, 81, 107, 73, 129, 145, 196, 4, 98,
      253, 120, 15, 235, 108, 37, 198, 124, 111, 38, 1, 210, 143, 72, 87,
    ]);
    const scenarioSharedSecret = x25519.getSharedSecret(
      scenarioPrivateKey,
      scenarioMxePublicKey
    );
    const scenarioCipher = new RescueCipher(scenarioSharedSecret);

    // Play multiple games
    const games = [
      { player: 0, house: 0 }, // Rock vs Rock (Tie)
      { player: 0, house: 2 }, // Rock vs Scissors (Win)
      { player: 1, house: 0 }, // Paper vs Rock (Win)
      { player: 2, house: 1 }, // Scissors vs Paper (Win)
      { player: 2, house: 0 }, // Scissors vs Rock (Loss)
      { player: 1, house: 2 }, // Paper vs Scissors (Loss)
    ];

    for (const game of games) {
      console.log(
        `\n--- Testing game scenario: Player ${game.player} vs House ${game.house} ---`
      );

      // Initialize a new game for this scenario
      const scenarioGameId = new anchor.BN(
        Date.now() + Math.floor(Math.random() * 1000)
      );
      const scenarioNonce = randomBytes(16);

      const initComputationOffset3 = new anchor.BN(randomBytes(8), "hex");

      console.log("Initializing a new game");
      const initGameTx = await program.methods
        .initGame(
          initComputationOffset3,
          scenarioGameId,
          playerA.publicKey,
          playerB.publicKey,
          new anchor.BN(deserializeLE(scenarioNonce).toString())
        )
        .accounts({
          computationAccount: getComputationAccAddress(
            program.programId,
            initComputationOffset3
          ),
          payer: owner.publicKey,
          mxeAccount: getMXEAccAddress(program.programId),
          mempoolAccount: getMempoolAccAddress(program.programId),
          executingPool: getExecutingPoolAccAddress(program.programId),
          compDefAccount: getCompDefAccAddress(
            program.programId,
            Buffer.from(getCompDefAccOffset("init_game")).readUInt32LE()
          ),
          clusterAccount: arciumEnv.arciumClusterPubkey,
        })
        .signers([owner])
        .rpc({ commitment: "confirmed" });

      console.log("Game initialized with signature:", initGameTx);

      // Wait for initGame computation finalization
      const initGameFinalizeSig = await awaitComputationFinalization(
        provider as anchor.AnchorProvider,
        initComputationOffset3,
        program.programId,
        "confirmed"
      );
      console.log("Init game finalize signature:", initGameFinalizeSig);

      // Player A makes a move
      const playerAMoveNonce = randomBytes(16);
      const playerAMoveCiphertext = playerACipher.encrypt(
        [BigInt(0), BigInt(game.player)],
        playerAMoveNonce
      );

      const playerAMoveComputationOffset = new anchor.BN(randomBytes(8), "hex");

      console.log("Player A making a move");
      const playerAMoveTx = await program.methods
        .playerMove(
          playerAMoveComputationOffset,
          Array.from(playerAMoveCiphertext[0]),
          Array.from(playerAMoveCiphertext[1]),
          Array.from(playerAPublicKey),
          new anchor.BN(deserializeLE(playerAMoveNonce).toString())
        )
        .accounts({
          computationAccount: getComputationAccAddress(
            program.programId,
            playerAMoveComputationOffset
          ),
          payer: playerA.publicKey,
          mxeAccount: getMXEAccAddress(program.programId),
          mempoolAccount: getMempoolAccAddress(program.programId),
          executingPool: getExecutingPoolAccAddress(program.programId),
          compDefAccount: getCompDefAccAddress(
            program.programId,
            Buffer.from(getCompDefAccOffset("player_move")).readUInt32LE()
          ),
          clusterAccount: arciumEnv.arciumClusterPubkey,
          rpsGame: PublicKey.findProgramAddressSync(
            [
              Buffer.from("rps_game"),
              scenarioGameId.toArrayLike(Buffer, "le", 8),
            ],
            program.programId
          )[0],
        })
        .signers([playerA])
        .rpc({ commitment: "confirmed" });

      console.log("Player A move signature:", playerAMoveTx);

      // Wait for player A move computation finalization
      const playerAMoveFinalizeSig = await awaitComputationFinalization(
        provider as anchor.AnchorProvider,
        playerAMoveComputationOffset,
        program.programId,
        "confirmed"
      );
      console.log("Player A move finalize signature:", playerAMoveFinalizeSig);

      // Player B makes a move
      const playerBMoveNonce = randomBytes(16);
      const playerBMoveCiphertext = playerBCipher.encrypt(
        [BigInt(1), BigInt(game.house)],
        playerBMoveNonce
      );

      const playerBMoveComputationOffset = new anchor.BN(randomBytes(8), "hex");

      console.log("Player B making a move");
      const playerBMoveTx = await program.methods
        .playerMove(
          playerBMoveComputationOffset,
          Array.from(playerBMoveCiphertext[0]),
          Array.from(playerBMoveCiphertext[1]),
          Array.from(playerBPublicKey),
          new anchor.BN(deserializeLE(playerBMoveNonce).toString())
        )
        .accounts({
          computationAccount: getComputationAccAddress(
            program.programId,
            playerBMoveComputationOffset
          ),
          payer: playerB.publicKey,
          mxeAccount: getMXEAccAddress(program.programId),
          mempoolAccount: getMempoolAccAddress(program.programId),
          executingPool: getExecutingPoolAccAddress(program.programId),
          compDefAccount: getCompDefAccAddress(
            program.programId,
            Buffer.from(getCompDefAccOffset("player_move")).readUInt32LE()
          ),
          clusterAccount: arciumEnv.arciumClusterPubkey,
          rpsGame: PublicKey.findProgramAddressSync(
            [
              Buffer.from("rps_game"),
              scenarioGameId.toArrayLike(Buffer, "le", 8),
            ],
            program.programId
          )[0],
        })
        .signers([playerB])
        .rpc({ commitment: "confirmed" });

      console.log("Player B move signature:", playerBMoveTx);

      // Wait for player B move computation finalization
      const playerBMoveFinalizeSig = await awaitComputationFinalization(
        provider as anchor.AnchorProvider,
        playerBMoveComputationOffset,
        program.programId,
        "confirmed"
      );
      console.log("Player B move finalize signature:", playerBMoveFinalizeSig);

      // Compare moves to determine the winner
      const gameEventPromise = awaitEvent("compareMovesEvent");

      const compareComputationOffset = new anchor.BN(randomBytes(8), "hex");

      console.log("Comparing moves");
      const compareTx = await program.methods
        .compareMoves(compareComputationOffset)
        .accounts({
          computationAccount: getComputationAccAddress(
            program.programId,
            compareComputationOffset
          ),
          payer: owner.publicKey,
          mxeAccount: getMXEAccAddress(program.programId),
          mempoolAccount: getMempoolAccAddress(program.programId),
          executingPool: getExecutingPoolAccAddress(program.programId),
          compDefAccount: getCompDefAccAddress(
            program.programId,
            Buffer.from(getCompDefAccOffset("compare_moves")).readUInt32LE()
          ),
          clusterAccount: arciumEnv.arciumClusterPubkey,
          rpsGame: PublicKey.findProgramAddressSync(
            [
              Buffer.from("rps_game"),
              scenarioGameId.toArrayLike(Buffer, "le", 8),
            ],
            program.programId
          )[0],
        })
        .rpc({ commitment: "confirmed" });

      console.log("Compare moves signature:", compareTx);

      const finalizeSig = await awaitComputationFinalization(
        provider as anchor.AnchorProvider,
        compareComputationOffset,
        program.programId,
        "confirmed"
      );
      console.log("Finalize signature:", finalizeSig);

      const gameEvent = await gameEventPromise;
      console.log(`Game result: ${gameEvent.result}`);

      // Verify the result based on the expected outcome
      let expectedResult: string;
      if (game.player === game.house) {
        expectedResult = "Tie";
      } else if (
        (game.player === 0 && game.house === 2) || // Rock beats Scissors
        (game.player === 1 && game.house === 0) || // Paper beats Rock
        (game.player === 2 && game.house === 1) // Scissors beats Paper
      ) {
        expectedResult = "Player A Wins";
      } else {
        expectedResult = "Player B Wins";
      }

      expect(gameEvent.result).to.equal(expectedResult);
    }

    // Step 5: Test invalid move scenario
    console.log("\n--- Testing invalid move scenario ---");

    // Initialize a new game for this scenario
    const gameId3 = new anchor.BN(
      Date.now() + Math.floor(Math.random() * 1000)
    );
    const nonce3 = randomBytes(16);

    const initComputationOffset4 = new anchor.BN(randomBytes(8), "hex");

    console.log("Initializing a new game for invalid move test");
    const initGameTx3 = await program.methods
      .initGame(
        initComputationOffset4,
        gameId3,
        playerA.publicKey,
        playerB.publicKey,
        new anchor.BN(deserializeLE(nonce3).toString())
      )
      .accounts({
        computationAccount: getComputationAccAddress(
          program.programId,
          initComputationOffset4
        ),
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("init_game")).readUInt32LE()
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
      })
      .signers([owner])
      .rpc({ commitment: "confirmed" });

    console.log("Game initialized for invalid move test:", initGameTx3);

    // Wait for initGame computation finalization
    const initGameFinalizeSig3 = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      initComputationOffset4,
      program.programId,
      "confirmed"
    );
    console.log(
      "Init game finalize signature for invalid move test:",
      initGameFinalizeSig3
    );

    // Player A makes a valid move (Rock = 0)
    const playerAValidMove = 0;
    const playerAId3 = 0;
    const playerANonce3 = randomBytes(16);
    const playerACiphertext3 = playerACipher.encrypt(
      [BigInt(playerAId3), BigInt(playerAValidMove)],
      playerANonce3
    );

    const playerAMoveComputationOffset3 = new anchor.BN(randomBytes(8), "hex");

    console.log("Player A making a valid move (0)");
    const playerAMoveTx3 = await program.methods
      .playerMove(
        playerAMoveComputationOffset3,
        Array.from(playerACiphertext3[0]),
        Array.from(playerACiphertext3[1]),
        Array.from(playerAPublicKey),
        new anchor.BN(deserializeLE(playerANonce3).toString())
      )
      .accounts({
        computationAccount: getComputationAccAddress(
          program.programId,
          playerAMoveComputationOffset3
        ),
        payer: playerA.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("player_move")).readUInt32LE()
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
        rpsGame: PublicKey.findProgramAddressSync(
          [Buffer.from("rps_game"), gameId3.toArrayLike(Buffer, "le", 8)],
          program.programId
        )[0],
      })
      .signers([playerA])
      .rpc({ commitment: "confirmed" });

    console.log("Player A valid move signature:", playerAMoveTx3);

    // Wait for player A move computation finalization
    const playerAMoveFinalizeSig3 = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      playerAMoveComputationOffset3,
      program.programId,
      "confirmed"
    );
    console.log("Player A move finalize signature:", playerAMoveFinalizeSig3);

    // Player B makes an invalid move (4)
    const playerBInvalidMove = 4;
    const playerBId3 = 1;
    const playerBNonce3 = randomBytes(16);
    const playerBCiphertext3 = playerBCipher.encrypt(
      [BigInt(playerBId3), BigInt(playerBInvalidMove)],
      playerBNonce3
    );

    const playerBMoveComputationOffset3 = new anchor.BN(randomBytes(8), "hex");

    console.log("Player B making an invalid move (4)");
    const playerBMoveTx3 = await program.methods
      .playerMove(
        playerBMoveComputationOffset3,
        Array.from(playerBCiphertext3[0]),
        Array.from(playerBCiphertext3[1]),
        Array.from(playerBPublicKey),
        new anchor.BN(deserializeLE(playerBNonce3).toString())
      )
      .accounts({
        computationAccount: getComputationAccAddress(
          program.programId,
          playerBMoveComputationOffset3
        ),
        payer: playerB.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("player_move")).readUInt32LE()
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
        rpsGame: PublicKey.findProgramAddressSync(
          [Buffer.from("rps_game"), gameId3.toArrayLike(Buffer, "le", 8)],
          program.programId
        )[0],
      })
      .signers([playerB])
      .rpc({ commitment: "confirmed" });

    console.log("Player B invalid move signature:", playerBMoveTx3);

    // Wait for player B move computation finalization
    const playerBMoveFinalizeSig3 = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      playerBMoveComputationOffset3,
      program.programId,
      "confirmed"
    );
    console.log("Player B move finalize signature:", playerBMoveFinalizeSig3);

    // Compare moves
    const gameEventPromise3 = awaitEvent("compareMovesEvent");

    const compareComputationOffset3 = new anchor.BN(randomBytes(8), "hex");

    console.log("Comparing moves for invalid move test");
    const compareTx3 = await program.methods
      .compareMoves(compareComputationOffset3)
      .accounts({
        computationAccount: getComputationAccAddress(
          program.programId,
          compareComputationOffset3
        ),
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("compare_moves")).readUInt32LE()
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
        rpsGame: PublicKey.findProgramAddressSync(
          [Buffer.from("rps_game"), gameId3.toArrayLike(Buffer, "le", 8)],
          program.programId
        )[0],
      })
      .rpc({ commitment: "confirmed" });

    console.log("Compare moves signature for invalid move test:", compareTx3);

    const finalizeSig3 = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      compareComputationOffset3,
      program.programId,
      "confirmed"
    );
    console.log("Finalize signature for invalid move test:", finalizeSig3);

    const gameEvent3 = await gameEventPromise3;
    console.log(`Game result for invalid move test: ${gameEvent3.result}`);

    // Verify the result is "Invalid Move"
    expect(gameEvent3.result).to.equal("Invalid Move");
  });
});

// Helper function to read keypair from JSON file
function readKpJson(path: string): anchor.web3.Keypair {
  const file = fs.readFileSync(path);
  return anchor.web3.Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(file.toString()))
  );
}

// Separate functions for each computation definition type
async function initInitGameCompDef(
  program: Program<RockPaperScissors>,
  owner: anchor.web3.Keypair,
  uploadRawCircuit: boolean,
  offchainSource: boolean
): Promise<string> {
  const baseSeedCompDefAcc = getArciumAccountBaseSeed(
    "ComputationDefinitionAccount"
  );
  const offset = getCompDefAccOffset("init_game");

  const compDefPDA = PublicKey.findProgramAddressSync(
    [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
    getArciumProgAddress()
  )[0];

  console.log(`Comp def PDA for init_game:`, compDefPDA.toBase58());

  const sig = await program.methods
    .initInitGameCompDef()
    .accounts({
      compDefAccount: compDefPDA,
      payer: owner.publicKey,
      mxeAccount: getMXEAccAddress(program.programId),
    })
    .signers([owner])
    .rpc({
      commitment: "confirmed",
    });

  console.log(`Init init_game computation definition transaction`, sig);

  if (uploadRawCircuit) {
    const rawCircuit = fs.readFileSync(`build/init_game.arcis`);
    await uploadCircuit(
      program.provider as anchor.AnchorProvider,
      "init_game",
      program.programId,
      rawCircuit,
      true
    );
  } else if (!offchainSource) {
    const finalizeTx = await buildFinalizeCompDefTx(
      program.provider as anchor.AnchorProvider,
      Buffer.from(offset).readUInt32LE(),
      program.programId
    );

    const latestBlockhash =
      await program.provider.connection.getLatestBlockhash();
    finalizeTx.recentBlockhash = latestBlockhash.blockhash;
    finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;

    finalizeTx.sign(owner);
    await program.provider.sendAndConfirm(finalizeTx);
  }
  return sig;
}

async function initPlayerMoveCompDef(
  program: Program<RockPaperScissors>,
  owner: anchor.web3.Keypair,
  uploadRawCircuit: boolean,
  offchainSource: boolean
): Promise<string> {
  const baseSeedCompDefAcc = getArciumAccountBaseSeed(
    "ComputationDefinitionAccount"
  );
  const offset = getCompDefAccOffset("player_move");

  const compDefPDA = PublicKey.findProgramAddressSync(
    [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
    getArciumProgAddress()
  )[0];

  console.log(`Comp def PDA for player_move:`, compDefPDA.toBase58());

  const sig = await program.methods
    .initPlayerMoveCompDef()
    .accounts({
      compDefAccount: compDefPDA,
      payer: owner.publicKey,
      mxeAccount: getMXEAccAddress(program.programId),
    })
    .signers([owner])
    .rpc({
      commitment: "confirmed",
    });

  console.log(`Init player_move computation definition transaction`, sig);

  if (uploadRawCircuit) {
    const rawCircuit = fs.readFileSync(`build/player_move.arcis`);
    await uploadCircuit(
      program.provider as anchor.AnchorProvider,
      "player_move",
      program.programId,
      rawCircuit,
      true
    );
  } else if (!offchainSource) {
    const finalizeTx = await buildFinalizeCompDefTx(
      program.provider as anchor.AnchorProvider,
      Buffer.from(offset).readUInt32LE(),
      program.programId
    );

    const latestBlockhash =
      await program.provider.connection.getLatestBlockhash();
    finalizeTx.recentBlockhash = latestBlockhash.blockhash;
    finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;

    finalizeTx.sign(owner);
    await program.provider.sendAndConfirm(finalizeTx);
  }
  return sig;
}

async function initCompareMovesCompDef(
  program: Program<RockPaperScissors>,
  owner: anchor.web3.Keypair,
  uploadRawCircuit: boolean,
  offchainSource: boolean
): Promise<string> {
  const baseSeedCompDefAcc = getArciumAccountBaseSeed(
    "ComputationDefinitionAccount"
  );
  const offset = getCompDefAccOffset("compare_moves");

  const compDefPDA = PublicKey.findProgramAddressSync(
    [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
    getArciumProgAddress()
  )[0];

  console.log(`Comp def PDA for compare_moves:`, compDefPDA.toBase58());

  const sig = await program.methods
    .initCompareMovesCompDef()
    .accounts({
      compDefAccount: compDefPDA,
      payer: owner.publicKey,
      mxeAccount: getMXEAccAddress(program.programId),
    })
    .signers([owner])
    .rpc({
      commitment: "confirmed",
    });

  console.log(`Init compare_moves computation definition transaction`, sig);

  if (uploadRawCircuit) {
    const rawCircuit = fs.readFileSync(`build/compare_moves.arcis`);
    await uploadCircuit(
      program.provider as anchor.AnchorProvider,
      "compare_moves",
      program.programId,
      rawCircuit,
      true
    );
  } else if (!offchainSource) {
    const finalizeTx = await buildFinalizeCompDefTx(
      program.provider as anchor.AnchorProvider,
      Buffer.from(offset).readUInt32LE(),
      program.programId
    );

    const latestBlockhash =
      await program.provider.connection.getLatestBlockhash();
    finalizeTx.recentBlockhash = latestBlockhash.blockhash;
    finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;

    finalizeTx.sign(owner);
    await program.provider.sendAndConfirm(finalizeTx);
  }
  return sig;
}

async function getMXEPublicKeyWithRetry(
  provider: anchor.AnchorProvider,
  programId: PublicKey,
  maxRetries: number = 10,
  retryDelayMs: number = 500
): Promise<Uint8Array> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const mxePublicKey = await getMXEPublicKey(provider, programId);
      if (mxePublicKey) {
        return mxePublicKey;
      }
    } catch (error) {
      console.log(`Attempt ${attempt} failed to fetch MXE public key:`, error);
    }

    if (attempt < maxRetries) {
      console.log(
        `Retrying in ${retryDelayMs}ms... (attempt ${attempt}/${maxRetries})`
      );
      await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
    }
  }

  throw new Error(
    `Failed to fetch MXE public key after ${maxRetries} attempts`
  );
}



================================================
FILE: share_medical_records/README.md
================================================
# Share Medical Records

## The Problem: Privacy-Preserving Medical Data Sharing

Medical records contain highly sensitive personal information that needs to be shared between healthcare providers, insurance companies, and patients while maintaining strict privacy controls. Traditional solutions face several challenges:

- **Privacy Risks**: Storing medical data on public blockchains exposes sensitive information
- **Trust Requirements**: Centralized solutions require trusting a single party with sensitive data
- **Compliance**: Healthcare data sharing must comply with regulations like HIPAA
- **Access Control**: Fine-grained control over who can access specific medical data is essential
- **Auditability**: All access and sharing events must be transparent and verifiable

## The Solution: Arcium's MPC Network

This example demonstrates how Arcium's Multi-Party Computation (MPC) solution enables decentralized, trust-minimized confidential computing on Solana. The system allows medical records to be shared while keeping the data encrypted and ensuring no single party has access to the complete information.

### Key Features

- **Dishonest Majority MPC**: Secure computation even when a majority of nodes are potentially malicious
- **Cheater Detection**: Built-in mechanisms to detect and prevent malicious behavior
- **Trustless Architecture**: No single party has access to the complete data
- **Regulatory Compliance**: Built-in privacy controls align with healthcare data regulations
- **Transparent Access**: All sharing events are recorded on-chain while preserving privacy
- **Selective Sharing**: Patients maintain control over who can access their medical data

### Encryption Flow

- Data remains encrypted at all times during storage and computation
- Only the authorized recipient can decrypt the data using their private key
- The MPC network performs computations on encrypted data without ever seeing the plaintext
- When sharing data, it's encrypted specifically for the recipient's public key
- The recipient can then decrypt the data using their private key when they receive it

## Implementation Details

### Architecture

- Regular Solana program code in the `programs` directory
- Confidential computing instructions in the `encrypted-ixs` directory using Arcium's Arcis framework
- Seamless integration with Solana's account model and Anchor framework

### Key Components

- **Encrypted Circuit**: Defined in `encrypted-ixs/src/lib.rs`, handles confidential data transfer
- **Program Instructions**:
  - `init_share_patient_data_comp_def`: Initializes the confidential computation
  - `store_patient_data`: Stores encrypted patient data on-chain
  - `share_patient_data`: Initiates the confidential data sharing process
  - `share_patient_data_callback`: Handles the computation result

### Security Implementation

- Threshold encryption requiring multiple parties to cooperate
- Separate encryption keys for sender and receiver
- Nonce-based protection against replay attacks
- Secure enclave environment for computation
- Decentralized MPC nodes with no single point of failure

### Example Flow

The test file (`share_medical_records.ts`) demonstrates:

1. Computation definition initialization
2. Encrypted patient data storage
3. Secure data sharing with a receiver
4. Verification through on-chain events

This example effectively showcases how Arcium's MPC solution enables:

- Decentralized computation without any single trusted party
- Privacy-preserving data sharing on public blockchains
- Secure handling of sensitive medical information
- Integration with existing blockchain infrastructure
- Practical implementation of complex privacy-preserving protocols



================================================
FILE: share_medical_records/Anchor.toml
================================================
[toolchain]
package_manager = "yarn"

[features]
resolution = true
skip-lint = false

[programs.localnet]
share_medical_records = "NEnkfYAYz9epwXkXChP3hz2y1L8wUgf2xkrUKAmfxBD"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"



================================================
FILE: share_medical_records/Arcium.toml
================================================
[localnet]
# number of nodes in the single cluster of the localnet
nodes = 2
# number of seconds to wait for the localnet to come online
localnet_timeout_secs = 60
# MPC backends this MXE supports (default: ["Cerberus"])
# Supported values: "Cerberus", "Manticore", or both
# Examples: backends = ["Cerberus"] or backends = ["Cerberus", "Manticore"]
backends = ["Cerberus"]
# Required when backends includes "Manticore"
# Each path is copied to corresponding node's artifacts/manticore/computation_folder_N
# Example: manticore_data_folders = ["./data/player-0", "./data/player-1"]
# manticore_data_folders = []


================================================
FILE: share_medical_records/Cargo.toml
================================================
[workspace]
members = ["programs/*", "encrypted-ixs"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
[patch.crates-io]
proc-macro2 = { git = 'https://github.com/arcium-hq/proc-macro2.git' }


================================================
FILE: share_medical_records/package.json
================================================
{
  "license": "ISC",
  "scripts": {
    "lint:fix": "prettier */*.js \"*/**/*{.js,.ts}\" -w",
    "lint": "prettier */*.js \"*/**/*{.js,.ts}\" --check"
  },
  "dependencies": {
    "@coral-xyz/anchor": "^0.31.1",
    "@arcium-hq/client": "0.3.0"
  },
  "devDependencies": {
    "chai": "^4.3.4",
    "mocha": "^9.0.3",
    "ts-mocha": "^10.0.0",
    "@types/bn.js": "^5.1.0",
    "@types/chai": "^4.3.0",
    "@types/mocha": "^9.0.0",
    "typescript": "^4.3.5",
    "prettier": "^2.6.2"
  }
}



================================================
FILE: share_medical_records/rust-toolchain
================================================
1.88.0



================================================
FILE: share_medical_records/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}



================================================
FILE: share_medical_records/.prettierignore
================================================
.anchor
.DS_Store
target
node_modules
dist
build
test-ledger



================================================
FILE: share_medical_records/encrypted-ixs/Cargo.toml
================================================
[package]
name = "encrypted-ixs"
version = "0.1.0"
edition = "2021"

[dependencies]
arcis-imports = { version = "0.3.0" }



================================================
FILE: share_medical_records/encrypted-ixs/src/lib.rs
================================================
use arcis_imports::*;

#[encrypted]
mod circuits {
    use arcis_imports::*;

    pub struct PatientData {
        pub patient_id: u64,
        pub age: u8,
        pub gender: bool,
        pub blood_type: u8,
        pub weight: u16,
        pub height: u16,
        pub allergies: [bool; 5],
    }

    #[instruction]
    pub fn share_patient_data(
        receiver: Shared,
        input_ctxt: Enc<Shared, PatientData>,
    ) -> Enc<Shared, PatientData> {
        let input = input_ctxt.to_arcis();
        receiver.from_arcis(input)
    }
}



================================================
FILE: share_medical_records/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

import * as anchor from "@coral-xyz/anchor";

module.exports = async function (provider: anchor.AnchorProvider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};



================================================
FILE: share_medical_records/programs/share_medical_records/Cargo.toml
================================================
[package]
name = "share_medical_records"
version = "0.1.0"
description = "Created with Arcium & Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "share_medical_records"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { version = "0.31.1", features = ["init-if-needed"] }

arcium-client = { version = "0.3.0", default-features = false }
arcium-macros = { version = "0.3.0" }
arcium-anchor = { version = "0.3.0" }



================================================
FILE: share_medical_records/programs/share_medical_records/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []



================================================
FILE: share_medical_records/programs/share_medical_records/src/lib.rs
================================================
use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;

const COMP_DEF_OFFSET_SHARE_PATIENT_DATA: u32 = comp_def_offset("share_patient_data");

declare_id!("NEnkfYAYz9epwXkXChP3hz2y1L8wUgf2xkrUKAmfxBD");

#[arcium_program]
pub mod share_medical_records {
    use super::*;

    /// Stores encrypted patient medical data on-chain.
    ///
    /// This function stores patient medical information in encrypted form. All data fields
    /// are provided as encrypted 32-byte arrays that can only be decrypted by authorized parties.
    /// The data remains confidential while being stored on the public Solana blockchain.
    ///
    /// # Arguments
    /// * `patient_id` - Encrypted unique identifier for the patient
    /// * `age` - Encrypted patient age
    /// * `gender` - Encrypted patient gender information
    /// * `blood_type` - Encrypted blood type information
    /// * `weight` - Encrypted patient weight
    /// * `height` - Encrypted patient height
    /// * `allergies` - Array of encrypted allergy information (up to 5 entries)
    pub fn store_patient_data(
        ctx: Context<StorePatientData>,
        patient_id: [u8; 32],
        age: [u8; 32],
        gender: [u8; 32],
        blood_type: [u8; 32],
        weight: [u8; 32],
        height: [u8; 32],
        allergies: [[u8; 32]; 5],
    ) -> Result<()> {
        let patient_data = &mut ctx.accounts.patient_data;
        patient_data.patient_id = patient_id;
        patient_data.age = age;
        patient_data.gender = gender;
        patient_data.blood_type = blood_type;
        patient_data.weight = weight;
        patient_data.height = height;
        patient_data.allergies = allergies;

        Ok(())
    }

    pub fn init_share_patient_data_comp_def(
        ctx: Context<InitSharePatientDataCompDef>,
    ) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    /// Initiates confidential sharing of patient data with a specified receiver.
    ///
    /// This function triggers an MPC computation that re-encrypts the patient's medical data
    /// for a specific receiver. The receiver will be able to decrypt the data using their
    /// private key, while the data remains encrypted for everyone else. The original
    /// stored data is not modified and remains encrypted for the original owner.
    ///
    /// # Arguments
    /// * `receiver` - Public key of the authorized recipient
    /// * `receiver_nonce` - Cryptographic nonce for the receiver's encryption
    /// * `sender_pub_key` - Sender's public key for the operation
    /// * `nonce` - Cryptographic nonce for the sender's encryption
    pub fn share_patient_data(
        ctx: Context<SharePatientData>,
        computation_offset: u64,
        receiver: [u8; 32],
        receiver_nonce: u128,
        sender_pub_key: [u8; 32],
        nonce: u128,
    ) -> Result<()> {
        let args = vec![
            Argument::ArcisPubkey(receiver),
            Argument::PlaintextU128(receiver_nonce),
            Argument::ArcisPubkey(sender_pub_key),
            Argument::PlaintextU128(nonce),
            Argument::Account(
                ctx.accounts.patient_data.key(),
                8,
                PatientData::INIT_SPACE as u32,
            ),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![SharePatientDataCallback::callback_ix(&[])],
        )?;
        Ok(())
    }

    /// Handles the result of the patient data sharing MPC computation.
    ///
    /// This callback processes the re-encrypted patient data that has been prepared for
    /// the specified receiver. It emits an event containing all the medical data fields
    /// encrypted specifically for the receiver's public key.
    #[arcium_callback(encrypted_ix = "share_patient_data")]
    pub fn share_patient_data_callback(
        ctx: Context<SharePatientDataCallback>,
        output: ComputationOutputs<SharePatientDataOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(SharePatientDataOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        emit!(ReceivedPatientDataEvent {
            nonce: o.nonce.to_le_bytes(),
            patient_id: o.ciphertexts[0],
            age: o.ciphertexts[1],
            gender: o.ciphertexts[2],
            blood_type: o.ciphertexts[3],
            weight: o.ciphertexts[4],
            height: o.ciphertexts[5],
            allergies: o.ciphertexts[6..11]
                .try_into()
                .map_err(|_| ErrorCode::InvalidAllergyData)?,
        });
        Ok(())
    }
}

#[derive(Accounts)]
pub struct StorePatientData<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    #[account(
        init,
        payer = payer,
        space = 8 + PatientData::INIT_SPACE,
        seeds = [b"patient_data", payer.key().as_ref()],
        bump,
    )]
    pub patient_data: Account<'info, PatientData>,
}

#[queue_computation_accounts("share_patient_data", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64)]
pub struct SharePatientData<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program.
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program.
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_SHARE_PATIENT_DATA)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    pub patient_data: Account<'info, PatientData>,
}

#[callback_accounts("share_patient_data")]
#[derive(Accounts)]
pub struct SharePatientDataCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_SHARE_PATIENT_DATA)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
}

#[init_computation_definition_accounts("share_patient_data", payer)]
#[derive(Accounts)]
pub struct InitSharePatientDataCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[event]
pub struct ReceivedPatientDataEvent {
    pub nonce: [u8; 16],
    pub patient_id: [u8; 32],
    pub age: [u8; 32],
    pub gender: [u8; 32],
    pub blood_type: [u8; 32],
    pub weight: [u8; 32],
    pub height: [u8; 32],
    pub allergies: [[u8; 32]; 5],
}

/// Stores encrypted patient medical information.
#[account]
#[derive(InitSpace)]
pub struct PatientData {
    /// Encrypted unique patient identifier
    pub patient_id: [u8; 32],
    /// Encrypted patient age
    pub age: [u8; 32],
    /// Encrypted gender information
    pub gender: [u8; 32],
    /// Encrypted blood type
    pub blood_type: [u8; 32],
    /// Encrypted weight measurement
    pub weight: [u8; 32],
    /// Encrypted height measurement
    pub height: [u8; 32],
    /// Array of encrypted allergy information (up to 5 allergies)
    pub allergies: [[u8; 32]; 5],
}

#[error_code]
pub enum ErrorCode {
    #[msg("The computation was aborted")]
    AbortedComputation,
    #[msg("Invalid allergy data format")]
    InvalidAllergyData,
    #[msg("Cluster not set")]
    ClusterNotSet,
}



================================================
FILE: share_medical_records/tests/share_medical_records.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { ShareMedicalRecords } from "../target/types/share_medical_records";
import { randomBytes } from "crypto";
import {
  awaitComputationFinalization,
  getArciumEnv,
  getCompDefAccOffset,
  getArciumAccountBaseSeed,
  getArciumProgAddress,
  uploadCircuit,
  buildFinalizeCompDefTx,
  RescueCipher,
  deserializeLE,
  getMXEAccAddress,
  getMempoolAccAddress,
  getCompDefAccAddress,
  getExecutingPoolAccAddress,
  x25519,
  getComputationAccAddress,
  getMXEPublicKey,
} from "@arcium-hq/client";
import * as fs from "fs";
import * as os from "os";
import { expect } from "chai";

describe("ShareMedicalRecords", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace
    .ShareMedicalRecords as Program<ShareMedicalRecords>;
  const provider = anchor.getProvider();

  type Event = anchor.IdlEvents<(typeof program)["idl"]>;
  const awaitEvent = async <E extends keyof Event>(eventName: E) => {
    let listenerId: number;
    const event = await new Promise<Event[E]>((res) => {
      listenerId = program.addEventListener(eventName, (event) => {
        res(event);
      });
    });
    await program.removeEventListener(listenerId);

    return event;
  };

  const arciumEnv = getArciumEnv();

  it("can store and share patient data confidentially!", async () => {
    const owner = readKpJson(`${os.homedir()}/.config/solana/id.json`);

    const mxePublicKey = await getMXEPublicKeyWithRetry(
      provider as anchor.AnchorProvider,
      program.programId
    );

    console.log("MXE x25519 pubkey is", mxePublicKey);

    console.log("Initializing share patient data computation definition");
    const initSPDSig = await initSharePatientDataCompDef(
      program,
      owner,
      false,
      false
    );
    console.log(
      "Share patient data computation definition initialized with signature",
      initSPDSig
    );

    const senderPrivateKey = x25519.utils.randomSecretKey();
    const senderPublicKey = x25519.getPublicKey(senderPrivateKey);
    const sharedSecret = x25519.getSharedSecret(senderPrivateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);

    const patientId = BigInt(420);
    const age = BigInt(69);
    const gender = BigInt(true);
    const bloodType = BigInt(1); // A+
    const weight = BigInt(70);
    const height = BigInt(170);
    // allergies are [peanuts, latex, bees, wasps, cats]
    const allergies = [
      BigInt(false),
      BigInt(true),
      BigInt(false),
      BigInt(true),
      BigInt(false),
    ];

    const patientData = [
      patientId,
      age,
      gender,
      bloodType,
      weight,
      height,
      ...allergies,
    ];

    const nonce = randomBytes(16);
    const ciphertext = cipher.encrypt(patientData, nonce);

    const storeSig = await program.methods
      .storePatientData(
        ciphertext[0],
        ciphertext[1],
        ciphertext[2],
        ciphertext[3],
        ciphertext[4],
        ciphertext[5],
        [
          ciphertext[6],
          ciphertext[7],
          ciphertext[8],
          ciphertext[9],
          ciphertext[10],
        ]
      )
      .rpc({ commitment: "confirmed" });
    console.log("Store sig is ", storeSig);

    const receiverSecretKey = x25519.utils.randomSecretKey();
    const receiverPubKey = x25519.getPublicKey(receiverSecretKey);
    const receiverNonce = randomBytes(16);

    const receivedPatientDataEventPromise = awaitEvent(
      "receivedPatientDataEvent"
    );

    const computationOffset = new anchor.BN(randomBytes(8), "hex");

    const queueSig = await program.methods
      .sharePatientData(
        computationOffset,
        Array.from(receiverPubKey),
        new anchor.BN(deserializeLE(receiverNonce).toString()),
        Array.from(senderPublicKey),
        new anchor.BN(deserializeLE(nonce).toString())
      )
      .accountsPartial({
        computationAccount: getComputationAccAddress(
          program.programId,
          computationOffset
        ),
        clusterAccount: arciumEnv.arciumClusterPubkey,
        mxeAccount: getMXEAccAddress(program.programId),
        mempoolAccount: getMempoolAccAddress(program.programId),
        executingPool: getExecutingPoolAccAddress(program.programId),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("share_patient_data")).readUInt32LE()
        ),
        patientData: PublicKey.findProgramAddressSync(
          [Buffer.from("patient_data"), owner.publicKey.toBuffer()],
          program.programId
        )[0],
      })
      .rpc({ commitment: "confirmed" });
    console.log("Queue sig is ", queueSig);

    const finalizeSig = await awaitComputationFinalization(
      provider as anchor.AnchorProvider,
      computationOffset,
      program.programId,
      "confirmed"
    );
    console.log("Finalize sig is ", finalizeSig);

    const receiverSharedSecret = x25519.getSharedSecret(
      receiverSecretKey,
      mxePublicKey
    );
    const receiverCipher = new RescueCipher(receiverSharedSecret);

    const receivedPatientDataEvent = await receivedPatientDataEventPromise;

    // Decrypt all patient data fields
    const decryptedFields = receiverCipher.decrypt(
      [
        receivedPatientDataEvent.patientId,
        receivedPatientDataEvent.age,
        receivedPatientDataEvent.gender,
        receivedPatientDataEvent.bloodType,
        receivedPatientDataEvent.weight,
        receivedPatientDataEvent.height,
        ...receivedPatientDataEvent.allergies,
      ],
      new Uint8Array(receivedPatientDataEvent.nonce)
    );

    // Verify all fields match the original data
    expect(decryptedFields[0]).to.equal(patientData[0], "Patient ID mismatch");
    expect(decryptedFields[1]).to.equal(patientData[1], "Age mismatch");
    expect(decryptedFields[2]).to.equal(patientData[2], "Gender mismatch");
    expect(decryptedFields[3]).to.equal(patientData[3], "Blood type mismatch");
    expect(decryptedFields[4]).to.equal(patientData[4], "Weight mismatch");
    expect(decryptedFields[5]).to.equal(patientData[5], "Height mismatch");

    // Verify allergies
    for (let i = 0; i < 5; i++) {
      expect(decryptedFields[6 + i]).to.equal(
        patientData[6 + i],
        `Allergy ${i} mismatch`
      );
    }

    console.log("All patient data fields successfully decrypted and verified");
  });

  async function initSharePatientDataCompDef(
    program: Program<ShareMedicalRecords>,
    owner: anchor.web3.Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("share_patient_data");

    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];

    console.log("Comp def pda is ", compDefPDA);

    const sig = await program.methods
      .initSharePatientDataCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .signers([owner])
      .rpc({
        commitment: "confirmed",
      });
    console.log(
      "Init share patient data computation definition transaction",
      sig
    );

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/share_patient_data.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "share_patient_data",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      const finalizeTx = await buildFinalizeCompDefTx(
        provider as anchor.AnchorProvider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );

      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;

      finalizeTx.sign(owner);

      await provider.sendAndConfirm(finalizeTx);
    }
    return sig;
  }
});

async function getMXEPublicKeyWithRetry(
  provider: anchor.AnchorProvider,
  programId: PublicKey,
  maxRetries: number = 10,
  retryDelayMs: number = 500
): Promise<Uint8Array> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const mxePublicKey = await getMXEPublicKey(provider, programId);
      if (mxePublicKey) {
        return mxePublicKey;
      }
    } catch (error) {
      console.log(`Attempt ${attempt} failed to fetch MXE public key:`, error);
    }

    if (attempt < maxRetries) {
      console.log(
        `Retrying in ${retryDelayMs}ms... (attempt ${attempt}/${maxRetries})`
      );
      await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
    }
  }

  throw new Error(
    `Failed to fetch MXE public key after ${maxRetries} attempts`
  );
}

function readKpJson(path: string): anchor.web3.Keypair {
  const file = fs.readFileSync(path);
  return anchor.web3.Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(file.toString()))
  );
}



================================================
FILE: voting/README.md
================================================
# Anonymous Voting with Arcium

This project demonstrates how to implement truly anonymous voting on Solana using Arcium's confidential computing capabilities. It showcases how to create private polls where individual votes remain confidential while still allowing for verifiable results.

## Why Arcium is Necessary for Anonymous Voting

Traditional blockchains are transparent by design, making it impossible to implement truly anonymous voting without additional privacy layers. Here's why Arcium is essential:

- **Public Nature of Blockchains**: All data on a regular blockchain is visible to everyone
- **Privacy Requirements**: Votes must remain confidential to ensure anonymity
- **Security Concerns**: Even encrypted votes would require decryption keys, creating vulnerabilities
- **Distributed Trust**: Arcium uses Multi-Party Computation (MPC) to achieve a trust-minimized setup for confidential computing

## How It Works

### 1. Poll Creation

```typescript
const pollSig = await program.methods.createNewPoll(
  POLL_ID,
  `Poll ${POLL_ID}: $SOL to 500?`,
  new anchor.BN(deserializeLE(pollNonce).toString())
);
```

- Creates a new poll with a unique ID and title
- Uses a cryptographic nonce for security operations
- Establishes the voting context on-chain

### 2. Voting Process

```typescript
const vote = BigInt(true);
const plaintext = [vote];
const nonce = randomBytes(16);
const ciphertext = cipher.encrypt(plaintext, nonce);
```

- Votes are encrypted using x25519 (key exchange) and RescueCipher
- Each vote uses a unique nonce for security
- Votes remain confidential even when stored on-chain

### 3. Confidential Computation

```typescript
const queueVoteSig = await program.methods.vote(
  POLL_ID,
  Array.from(ciphertext[0]),
  Array.from(publicKey),
  new anchor.BN(deserializeLE(nonce).toString())
);
```

- Encrypted votes are processed using MPC across multiple parties
- Computation is distributed across the Arcium network
- Individual vote values remain confidential throughout the computation

### 4. Result Revealed

```typescript
const revealQueueSig = await program.methods.revealResult(POLL_ID);
```

- Only the final result (e.g., majority vote) is revealed
- Individual votes remain confidential
- Results are computed through MPC and only the outcome is published



================================================
FILE: voting/Anchor.toml
================================================
[toolchain]
package_manager = "yarn"

[features]
resolution = true
skip-lint = false

[programs.localnet]
voting = "J7KTdhMTVhy7vtgyFSXi9SpptdTDmpg93pB53UdfuttF"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 2000000 tests/**/*.ts"



================================================
FILE: voting/Arcium.toml
================================================
[localnet]
# number of nodes in the single cluster of the localnet
nodes = 2
# number of seconds to wait for the localnet to come online
localnet_timeout_secs = 60
# MPC backends this MXE supports (default: ["Cerberus"])
# Supported values: "Cerberus", "Manticore", or both
# Examples: backends = ["Cerberus"] or backends = ["Cerberus", "Manticore"]
backends = ["Cerberus"]
# Required when backends includes "Manticore"
# Each path is copied to corresponding node's artifacts/manticore/computation_folder_N
# Example: manticore_data_folders = ["./data/player-0", "./data/player-1"]
# manticore_data_folders = []


================================================
FILE: voting/Cargo.toml
================================================
[workspace]
members = ["programs/*", "encrypted-ixs"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
[patch.crates-io]
proc-macro2 = { git = 'https://github.com/arcium-hq/proc-macro2.git' }


================================================
FILE: voting/package.json
================================================
{
  "license": "ISC",
  "scripts": {
    "lint:fix": "prettier */*.js \"*/**/*{.js,.ts}\" -w",
    "lint": "prettier */*.js \"*/**/*{.js,.ts}\" --check"
  },
  "dependencies": {
    "@coral-xyz/anchor": "^0.31.1",
    "@arcium-hq/client": "0.3.0"
  },
  "devDependencies": {
    "chai": "^4.3.4",
    "mocha": "^9.0.3",
    "ts-mocha": "^10.0.0",
    "@types/bn.js": "^5.1.0",
    "@types/chai": "^4.3.0",
    "@types/mocha": "^9.0.0",
    "typescript": "^4.3.5",
    "prettier": "^2.6.2"
  }
}



================================================
FILE: voting/rust-toolchain
================================================
1.88.0



================================================
FILE: voting/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}



================================================
FILE: voting/.prettierignore
================================================
.anchor
.DS_Store
target
node_modules
dist
build
test-ledger



================================================
FILE: voting/encrypted-ixs/Cargo.toml
================================================
[package]
name = "encrypted-ixs"
version = "0.1.0"
edition = "2021"

[dependencies]
arcis-imports = { version = "0.3.0" }



================================================
FILE: voting/encrypted-ixs/src/lib.rs
================================================
use arcis_imports::*;

#[encrypted]
mod circuits {
    use arcis_imports::*;

    /// Tracks the encrypted vote tallies for a poll.
    pub struct VoteStats {
        yes: u64,
        no: u64,
    }

    /// Represents a single encrypted vote.
    pub struct UserVote {
        vote: bool,
    }

    /// Initializes encrypted vote counters for a new poll.
    ///
    /// Creates a VoteStats structure with zero counts for both yes and no votes.
    /// The counters remain encrypted and can only be updated through MPC operations.
    #[instruction]
    pub fn init_vote_stats(mxe: Mxe) -> Enc<Mxe, VoteStats> {
        let vote_stats = VoteStats { yes: 0, no: 0 };
        mxe.from_arcis(vote_stats)
    }

    /// Processes an encrypted vote and updates the running tallies.
    ///
    /// Takes an individual vote and adds it to the appropriate counter (yes or no)
    /// without revealing the vote value. The updated vote statistics remain encrypted
    /// and can only be revealed by the poll authority.
    ///
    /// # Arguments
    /// * `vote_ctxt` - The encrypted vote to be counted
    /// * `vote_stats_ctxt` - Current encrypted vote tallies
    ///
    /// # Returns
    /// Updated encrypted vote statistics with the new vote included
    #[instruction]
    pub fn vote(
        vote_ctxt: Enc<Shared, UserVote>,
        vote_stats_ctxt: Enc<Mxe, VoteStats>,
    ) -> Enc<Mxe, VoteStats> {
        let user_vote = vote_ctxt.to_arcis();
        let mut vote_stats = vote_stats_ctxt.to_arcis();

        // Increment appropriate counter based on vote value
        if user_vote.vote {
            vote_stats.yes += 1;
        } else {
            vote_stats.no += 1;
        }

        vote_stats_ctxt.owner.from_arcis(vote_stats)
    }

    /// Reveals the final result of the poll by comparing vote tallies.
    ///
    /// Decrypts the vote counters and determines whether the majority voted yes or no.
    /// Only the final result (majority decision) is revealed, not the actual vote counts.
    ///
    /// # Arguments
    /// * `vote_stats_ctxt` - Encrypted vote tallies to be revealed
    ///
    /// # Returns
    /// * `true` if more people voted yes than no
    /// * `false` if more people voted no than yes (or tie)
    #[instruction]
    pub fn reveal_result(vote_stats_ctxt: Enc<Mxe, VoteStats>) -> bool {
        let vote_stats = vote_stats_ctxt.to_arcis();
        (vote_stats.yes > vote_stats.no).reveal()
    }
}



================================================
FILE: voting/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

import * as anchor from "@coral-xyz/anchor";

module.exports = async function (provider: anchor.AnchorProvider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};



================================================
FILE: voting/programs/voting/Cargo.toml
================================================
[package]
name = "voting"
version = "0.1.0"
description = "Created with Arcium & Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "voting"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { version = "0.31.1", features = ["init-if-needed"] }

arcium-client = { version = "0.3.0", default-features = false }
arcium-macros = { version = "0.3.0" }
arcium-anchor = { version = "0.3.0" }



================================================
FILE: voting/programs/voting/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []



================================================
FILE: voting/programs/voting/src/lib.rs
================================================
use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;
use arcium_client::idl::arcium::types::CallbackAccount;

const COMP_DEF_OFFSET_INIT_VOTE_STATS: u32 = comp_def_offset("init_vote_stats");
const COMP_DEF_OFFSET_VOTE: u32 = comp_def_offset("vote");
const COMP_DEF_OFFSET_REVEAL: u32 = comp_def_offset("reveal_result");

declare_id!("J7KTdhMTVhy7vtgyFSXi9SpptdTDmpg93pB53UdfuttF");

#[arcium_program]
pub mod voting {
    use super::*;

    pub fn init_vote_stats_comp_def(ctx: Context<InitVoteStatsCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    /// Creates a new confidential poll with the given question.
    ///
    /// This initializes a poll account and sets up the encrypted vote counters using MPC.
    /// The vote tallies are stored in encrypted form and can only be revealed by the poll authority.
    /// All individual votes remain completely confidential throughout the voting process.
    ///
    /// # Arguments
    /// * `id` - Unique identifier for this poll
    /// * `question` - The poll question voters will respond to
    /// * `nonce` - Cryptographic nonce for initializing encrypted vote counters
    pub fn create_new_poll(
        ctx: Context<CreateNewPoll>,
        computation_offset: u64,
        id: u32,
        question: String,
        nonce: u128,
    ) -> Result<()> {
        msg!("Creating a new poll");

        // Initialize the poll account with the provided parameters
        ctx.accounts.poll_acc.question = question;
        ctx.accounts.poll_acc.bump = ctx.bumps.poll_acc;
        ctx.accounts.poll_acc.id = id;
        ctx.accounts.poll_acc.authority = ctx.accounts.payer.key();
        ctx.accounts.poll_acc.nonce = nonce;
        ctx.accounts.poll_acc.vote_state = [[0; 32]; 2];

        let args = vec![Argument::PlaintextU128(nonce)];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        // Initialize encrypted vote counters (yes/no) through MPC
        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![InitVoteStatsCallback::callback_ix(&[CallbackAccount {
                pubkey: ctx.accounts.poll_acc.key(),
                is_writable: true,
            }])],
        )?;

        Ok(())
    }

    #[arcium_callback(encrypted_ix = "init_vote_stats")]
    pub fn init_vote_stats_callback(
        ctx: Context<InitVoteStatsCallback>,
        output: ComputationOutputs<InitVoteStatsOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(InitVoteStatsOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        ctx.accounts.poll_acc.vote_state = o.ciphertexts;
        ctx.accounts.poll_acc.nonce = o.nonce;

        Ok(())
    }

    pub fn init_vote_comp_def(ctx: Context<InitVoteCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    /// Submits an encrypted vote to the poll.
    ///
    /// This function allows a voter to cast their vote (yes/no) in encrypted form.
    /// The vote is added to the running tally through MPC computation, ensuring
    /// that individual votes remain confidential while updating the overall count.
    ///
    /// # Arguments
    /// * `vote` - Encrypted vote (true for yes, false for no)
    /// * `vote_encryption_pubkey` - Voter's public key for encryption
    /// * `vote_nonce` - Cryptographic nonce for the vote encryption
    pub fn vote(
        ctx: Context<Vote>,
        computation_offset: u64,
        _id: u32,
        vote: [u8; 32],
        vote_encryption_pubkey: [u8; 32],
        vote_nonce: u128,
    ) -> Result<()> {
        let args = vec![
            Argument::ArcisPubkey(vote_encryption_pubkey),
            Argument::PlaintextU128(vote_nonce),
            Argument::EncryptedBool(vote),
            Argument::PlaintextU128(ctx.accounts.poll_acc.nonce),
            Argument::Account(
                ctx.accounts.poll_acc.key(),
                // Offset calculation: 8 bytes (discriminator) + 1 byte (bump)
                8 + 1,
                32 * 2, // 2 vote counters (yes/no), each stored as 32-byte ciphertext
            ),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![VoteCallback::callback_ix(&[CallbackAccount {
                pubkey: ctx.accounts.poll_acc.key(),
                is_writable: true,
            }])],
        )?;
        Ok(())
    }

    #[arcium_callback(encrypted_ix = "vote")]
    pub fn vote_callback(
        ctx: Context<VoteCallback>,
        output: ComputationOutputs<VoteOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(VoteOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        ctx.accounts.poll_acc.vote_state = o.ciphertexts;
        ctx.accounts.poll_acc.nonce = o.nonce;

        let clock = Clock::get()?;
        let current_timestamp = clock.unix_timestamp;

        emit!(VoteEvent {
            timestamp: current_timestamp,
        });

        Ok(())
    }

    pub fn init_reveal_result_comp_def(ctx: Context<InitRevealResultCompDef>) -> Result<()> {
        init_comp_def(ctx.accounts, true, 0, None, None)?;
        Ok(())
    }

    /// Reveals the final result of the poll.
    ///
    /// Only the poll authority can call this function to decrypt and reveal the vote tallies.
    /// The MPC computation compares the yes and no vote counts and returns whether
    /// the majority voted yes (true) or no (false).
    ///
    /// # Arguments
    /// * `id` - The poll ID to reveal results for
    pub fn reveal_result(
        ctx: Context<RevealVotingResult>,
        computation_offset: u64,
        id: u32,
    ) -> Result<()> {
        require!(
            ctx.accounts.payer.key() == ctx.accounts.poll_acc.authority,
            ErrorCode::InvalidAuthority
        );

        msg!("Revealing voting result for poll with id {}", id);

        let args = vec![
            Argument::PlaintextU128(ctx.accounts.poll_acc.nonce),
            Argument::Account(
                ctx.accounts.poll_acc.key(),
                // Offset calculation: 8 bytes (discriminator) + 1 byte (bump)
                8 + 1,
                32 * 2, // 2 encrypted vote counters (yes/no), 32 bytes each
            ),
        ];

        ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

        queue_computation(
            ctx.accounts,
            computation_offset,
            args,
            None,
            vec![RevealResultCallback::callback_ix(&[])],
        )?;
        Ok(())
    }

    #[arcium_callback(encrypted_ix = "reveal_result")]
    pub fn reveal_result_callback(
        ctx: Context<RevealResultCallback>,
        output: ComputationOutputs<RevealResultOutput>,
    ) -> Result<()> {
        let o = match output {
            ComputationOutputs::Success(RevealResultOutput { field_0 }) => field_0,
            _ => return Err(ErrorCode::AbortedComputation.into()),
        };

        emit!(RevealResultEvent { output: o });

        Ok(())
    }
}

#[queue_computation_accounts("init_vote_stats", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, id: u32)]
pub struct CreateNewPoll<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_INIT_VOTE_STATS)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        init,
        payer = payer,
        space = 8 + PollAccount::INIT_SPACE,
        seeds = [b"poll", payer.key().as_ref(), id.to_le_bytes().as_ref()],
        bump,
    )]
    pub poll_acc: Account<'info, PollAccount>,
}

#[callback_accounts("init_vote_stats")]
#[derive(Accounts)]
pub struct InitVoteStatsCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_INIT_VOTE_STATS)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    /// CHECK: poll_acc, checked by the callback account key passed in queue_computation
    #[account(mut)]
    pub poll_acc: Account<'info, PollAccount>,
}

#[init_computation_definition_accounts("init_vote_stats", payer)]
#[derive(Accounts)]
pub struct InitVoteStatsCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[queue_computation_accounts("vote", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, _id: u32)]
pub struct Vote<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_VOTE)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    /// CHECK: Poll authority pubkey
    #[account(
        address = poll_acc.authority,
    )]
    pub authority: UncheckedAccount<'info>,
    #[account(
        seeds = [b"poll", authority.key().as_ref(), _id.to_le_bytes().as_ref()],
        bump = poll_acc.bump,
        has_one = authority
    )]
    pub poll_acc: Account<'info, PollAccount>,
}

#[callback_accounts("vote")]
#[derive(Accounts)]
pub struct VoteCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_VOTE)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    #[account(mut)]
    pub poll_acc: Account<'info, PollAccount>,
}

#[init_computation_definition_accounts("vote", payer)]
#[derive(Accounts)]
pub struct InitVoteCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

#[queue_computation_accounts("reveal_result", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, id: u32)]
pub struct RevealVotingResult<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    #[account(
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Account<'info, MXEAccount>,
    #[account(
        mut,
        address = derive_mempool_pda!()
    )]
    /// CHECK: mempool_account, checked by the arcium program
    pub mempool_account: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_execpool_pda!()
    )]
    /// CHECK: executing_pool, checked by the arcium program
    pub executing_pool: UncheckedAccount<'info>,
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset)
    )]
    /// CHECK: computation_account, checked by the arcium program.
    pub computation_account: UncheckedAccount<'info>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_REVEAL)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account)
    )]
    pub cluster_account: Account<'info, Cluster>,
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        seeds = [b"poll", payer.key().as_ref(), id.to_le_bytes().as_ref()],
        bump = poll_acc.bump
    )]
    pub poll_acc: Account<'info, PollAccount>,
}

#[callback_accounts("reveal_result")]
#[derive(Accounts)]
pub struct RevealResultCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_REVEAL)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
}

#[init_computation_definition_accounts("reveal_result", payer)]
#[derive(Accounts)]
pub struct InitRevealResultCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program.
    /// Can't check it here as it's not initialized yet.
    pub comp_def_account: UncheckedAccount<'info>,
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

/// Represents a confidential poll with encrypted vote tallies.
#[account]
#[derive(InitSpace)]
pub struct PollAccount {
    /// PDA bump seed
    pub bump: u8,
    /// Encrypted vote counters: [yes_count, no_count] as 32-byte ciphertexts
    pub vote_state: [[u8; 32]; 2],
    /// Unique identifier for this poll
    pub id: u32,
    /// Public key of the poll creator (only they can reveal results)
    pub authority: Pubkey,
    /// Cryptographic nonce for the encrypted vote counters
    pub nonce: u128,
    /// The poll question (max 50 characters)
    #[max_len(50)]
    pub question: String,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Invalid authority")]
    InvalidAuthority,
    #[msg("The computation was aborted")]
    AbortedComputation,
    #[msg("Cluster not set")]
    ClusterNotSet,
}

#[event]
pub struct VoteEvent {
    pub timestamp: i64,
}

#[event]
pub struct RevealResultEvent {
    pub output: bool,
}



================================================
FILE: voting/tests/voting.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { Voting } from "../target/types/voting";
import { randomBytes } from "crypto";
import {
  awaitComputationFinalization,
  getArciumEnv,
  getCompDefAccOffset,
  getArciumAccountBaseSeed,
  getArciumProgAddress,
  uploadCircuit,
  buildFinalizeCompDefTx,
  RescueCipher,
  deserializeLE,
  getMXEAccAddress,
  getMempoolAccAddress,
  getCompDefAccAddress,
  getExecutingPoolAccAddress,
  x25519,
  getComputationAccAddress,
  getMXEPublicKey,
} from "@arcium-hq/client";
import * as fs from "fs";
import * as os from "os";
import { expect } from "chai";

describe("Voting", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.Voting as Program<Voting>;
  const provider = anchor.getProvider();

  type Event = anchor.IdlEvents<(typeof program)["idl"]>;
  const awaitEvent = async <E extends keyof Event>(eventName: E) => {
    let listenerId: number;
    const event = await new Promise<Event[E]>((res) => {
      listenerId = program.addEventListener(eventName, (event) => {
        res(event);
      });
    });
    await program.removeEventListener(listenerId);

    return event;
  };

  const arciumEnv = getArciumEnv();

  it("can vote on polls!", async () => {
    const POLL_IDS = [420, 421, 422];
    const owner = readKpJson(`${os.homedir()}/.config/solana/id.json`);

    const mxePublicKey = await getMXEPublicKeyWithRetry(
      provider as anchor.AnchorProvider,
      program.programId
    );

    console.log("MXE x25519 pubkey is", mxePublicKey);

    console.log("Initializing vote stats computation definition");
    const initVoteStatsSig = await initVoteStatsCompDef(
      program,
      owner,
      false,
      false
    );
    console.log(
      "Vote stats computation definition initialized with signature",
      initVoteStatsSig
    );

    console.log("Initializing voting computation definition");
    const initVoteSig = await initVoteCompDef(program, owner, false, false);
    console.log(
      "Vote computation definition initialized with signature",
      initVoteSig
    );

    console.log("Initializing reveal result computation definition");
    const initRRSig = await initRevealResultCompDef(
      program,
      owner,
      false,
      false
    );
    console.log(
      "Reveal result computation definition initialized with signature",
      initRRSig
    );

    const privateKey = x25519.utils.randomSecretKey();
    const publicKey = x25519.getPublicKey(privateKey);
    const sharedSecret = x25519.getSharedSecret(privateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);

    // Create multiple polls
    for (const POLL_ID of POLL_IDS) {
      const pollNonce = randomBytes(16);

      const pollComputationOffset = new anchor.BN(randomBytes(8), "hex");

      const pollSig = await program.methods
        .createNewPoll(
          pollComputationOffset,
          POLL_ID,
          `Poll ${POLL_ID}: $SOL to 500?`,
          new anchor.BN(deserializeLE(pollNonce).toString())
        )
        .accountsPartial({
          computationAccount: getComputationAccAddress(
            program.programId,
            pollComputationOffset
          ),
          clusterAccount: arciumEnv.arciumClusterPubkey,
          mxeAccount: getMXEAccAddress(program.programId),
          mempoolAccount: getMempoolAccAddress(program.programId),
          executingPool: getExecutingPoolAccAddress(program.programId),
          compDefAccount: getCompDefAccAddress(
            program.programId,
            Buffer.from(getCompDefAccOffset("init_vote_stats")).readUInt32LE()
          ),
        })
        .rpc({ skipPreflight: true, commitment: "confirmed" });

      console.log(`Poll ${POLL_ID} created with signature`, pollSig);

      const finalizePollSig = await awaitComputationFinalization(
        provider as anchor.AnchorProvider,
        pollComputationOffset,
        program.programId,
        "confirmed"
      );
      console.log(`Finalize poll ${POLL_ID} sig is `, finalizePollSig);
    }

    // Cast votes for each poll with different outcomes
    const voteOutcomes = [true, false, true]; // Different outcomes for each poll
    for (let i = 0; i < POLL_IDS.length; i++) {
      const POLL_ID = POLL_IDS[i];
      const vote = BigInt(voteOutcomes[i]);
      const plaintext = [vote];

      const nonce = randomBytes(16);
      const ciphertext = cipher.encrypt(plaintext, nonce);

      const voteEventPromise = awaitEvent("voteEvent");

      console.log(`Voting for poll ${POLL_ID}`);

      const voteComputationOffset = new anchor.BN(randomBytes(8), "hex");

      const queueVoteSig = await program.methods
        .vote(
          voteComputationOffset,
          POLL_ID,
          Array.from(ciphertext[0]),
          Array.from(publicKey),
          new anchor.BN(deserializeLE(nonce).toString())
        )
        .accountsPartial({
          computationAccount: getComputationAccAddress(
            program.programId,
            voteComputationOffset
          ),
          clusterAccount: arciumEnv.arciumClusterPubkey,
          mxeAccount: getMXEAccAddress(program.programId),
          mempoolAccount: getMempoolAccAddress(program.programId),
          executingPool: getExecutingPoolAccAddress(program.programId),
          compDefAccount: getCompDefAccAddress(
            program.programId,
            Buffer.from(getCompDefAccOffset("vote")).readUInt32LE()
          ),
          authority: owner.publicKey,
        })
        .rpc({ skipPreflight: true, commitment: "confirmed" });
      console.log(`Queue vote for poll ${POLL_ID} sig is `, queueVoteSig);

      const finalizeSig = await awaitComputationFinalization(
        provider as anchor.AnchorProvider,
        voteComputationOffset,
        program.programId,
        "confirmed"
      );
      console.log(`Finalize vote for poll ${POLL_ID} sig is `, finalizeSig);

      const voteEvent = await voteEventPromise;
      console.log(
        `Vote casted for poll ${POLL_ID} at timestamp `,
        voteEvent.timestamp.toString()
      );
    }

    // Reveal results for each poll
    for (let i = 0; i < POLL_IDS.length; i++) {
      const POLL_ID = POLL_IDS[i];
      const expectedOutcome = voteOutcomes[i];

      const revealEventPromise = awaitEvent("revealResultEvent");

      const revealComputationOffset = new anchor.BN(randomBytes(8), "hex");

      const revealQueueSig = await program.methods
        .revealResult(revealComputationOffset, POLL_ID)
        .accountsPartial({
          computationAccount: getComputationAccAddress(
            program.programId,
            revealComputationOffset
          ),
          clusterAccount: arciumEnv.arciumClusterPubkey,
          mxeAccount: getMXEAccAddress(program.programId),
          mempoolAccount: getMempoolAccAddress(program.programId),
          executingPool: getExecutingPoolAccAddress(program.programId),
          compDefAccount: getCompDefAccAddress(
            program.programId,
            Buffer.from(getCompDefAccOffset("reveal_result")).readUInt32LE()
          ),
        })
        .rpc({ skipPreflight: true, commitment: "confirmed" });
      console.log(`Reveal queue for poll ${POLL_ID} sig is `, revealQueueSig);

      const revealFinalizeSig = await awaitComputationFinalization(
        provider as anchor.AnchorProvider,
        revealComputationOffset,
        program.programId,
        "confirmed"
      );
      console.log(
        `Reveal finalize for poll ${POLL_ID} sig is `,
        revealFinalizeSig
      );

      const revealEvent = await revealEventPromise;
      console.log(
        `Decrypted winner for poll ${POLL_ID} is `,
        revealEvent.output
      );
      expect(revealEvent.output).to.equal(expectedOutcome);
    }
  });

  async function initVoteStatsCompDef(
    program: Program<Voting>,
    owner: anchor.web3.Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("init_vote_stats");

    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];

    console.log(
      "Init vote stats computation definition pda is ",
      compDefPDA.toBase58()
    );

    const sig = await program.methods
      .initVoteStatsCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .signers([owner])
      .rpc({
        commitment: "confirmed",
      });
    console.log("Init vote stats computation definition transaction", sig);

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/init_vote_stats.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "init_vote_stats",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      const finalizeTx = await buildFinalizeCompDefTx(
        provider as anchor.AnchorProvider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );

      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;

      finalizeTx.sign(owner);

      await provider.sendAndConfirm(finalizeTx);
    }
    return sig;
  }

  async function initVoteCompDef(
    program: Program<Voting>,
    owner: anchor.web3.Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("vote");

    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];

    console.log("Vote computation definition pda is ", compDefPDA.toBase58());

    const sig = await program.methods
      .initVoteCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .signers([owner])
      .rpc({
        commitment: "confirmed",
      });
    console.log("Init vote computation definition transaction", sig);

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/vote.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "vote",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      const finalizeTx = await buildFinalizeCompDefTx(
        provider as anchor.AnchorProvider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );

      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;

      finalizeTx.sign(owner);

      await provider.sendAndConfirm(finalizeTx);
    }
    return sig;
  }

  async function initRevealResultCompDef(
    program: Program<Voting>,
    owner: anchor.web3.Keypair,
    uploadRawCircuit: boolean,
    offchainSource: boolean
  ): Promise<string> {
    const baseSeedCompDefAcc = getArciumAccountBaseSeed(
      "ComputationDefinitionAccount"
    );
    const offset = getCompDefAccOffset("reveal_result");

    const compDefPDA = PublicKey.findProgramAddressSync(
      [baseSeedCompDefAcc, program.programId.toBuffer(), offset],
      getArciumProgAddress()
    )[0];

    console.log(
      "Reveal result computation definition pda is ",
      compDefPDA.toBase58()
    );

    const sig = await program.methods
      .initRevealResultCompDef()
      .accounts({
        compDefAccount: compDefPDA,
        payer: owner.publicKey,
        mxeAccount: getMXEAccAddress(program.programId),
      })
      .signers([owner])
      .rpc({
        commitment: "confirmed",
      });
    console.log("Init reveal result computation definition transaction", sig);

    if (uploadRawCircuit) {
      const rawCircuit = fs.readFileSync("build/reveal_result.arcis");

      await uploadCircuit(
        provider as anchor.AnchorProvider,
        "reveal_result",
        program.programId,
        rawCircuit,
        true
      );
    } else if (!offchainSource) {
      const finalizeTx = await buildFinalizeCompDefTx(
        provider as anchor.AnchorProvider,
        Buffer.from(offset).readUInt32LE(),
        program.programId
      );

      const latestBlockhash = await provider.connection.getLatestBlockhash();
      finalizeTx.recentBlockhash = latestBlockhash.blockhash;
      finalizeTx.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;

      finalizeTx.sign(owner);

      await provider.sendAndConfirm(finalizeTx);
    }
    return sig;
  }
});

async function getMXEPublicKeyWithRetry(
  provider: anchor.AnchorProvider,
  programId: PublicKey,
  maxRetries: number = 10,
  retryDelayMs: number = 500
): Promise<Uint8Array> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const mxePublicKey = await getMXEPublicKey(provider, programId);
      if (mxePublicKey) {
        return mxePublicKey;
      }
    } catch (error) {
      console.log(`Attempt ${attempt} failed to fetch MXE public key:`, error);
    }

    if (attempt < maxRetries) {
      console.log(
        `Retrying in ${retryDelayMs}ms... (attempt ${attempt}/${maxRetries})`
      );
      await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
    }
  }

  throw new Error(
    `Failed to fetch MXE public key after ${maxRetries} attempts`
  );
}

function readKpJson(path: string): anchor.web3.Keypair {
  const file = fs.readFileSync(path);
  return anchor.web3.Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(file.toString()))
  );
}



================================================
FILE: .github/actions/setup/action.yaml
================================================
name: "Setup"
description: "Setup"
runs:
  using: "composite"
  steps:
    - run: echo "RUST_VERSION=1.88.0" >> $GITHUB_ENV
      shell: bash
    - run: echo "ANCHOR_VERSION=0.31.1" >> $GITHUB_ENV
      shell: bash
    - run: echo "DEFAULT_ARCIUM_PROGRAMS_VERSION=0.3.0" >> $GITHUB_ENV
      shell: bash
    - run: echo "SOLANA_CLI_VERSION=2.1.6" >> $GITHUB_ENV
      shell: bash
    - run: echo "CARGO_TERM_COLOR=always" >> $GITHUB_ENV
      shell: bash
    - run: echo "RUSTFLAGS=-Dwarnings -A deprecated" >> $GITHUB_ENV
      shell: bash
    - run: echo "CARGO_NET_GIT_FETCH_WITH_CLI=true" >> $GITHUB_ENV
      shell: bash
    - run: echo "ARCUP_VERSION=0.3.0" >> $GITHUB_ENV
      shell: bash

    # Setup Rust with specific version
    - uses: actions-rs/toolchain@v1
      with:
        toolchain: 1.88.0
        override: true
        components: clippy

    - run: rustup update
      shell: bash

    # Cache cargo registry
    - uses: actions/cache@v4
      name: Cache Cargo Registry
      with:
        path: |
          ~/.cargo/registry/
          ~/.cargo/git/
          target/
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-

    - name: Set git-fetch-with-cli for Cargo
      run: |
        echo '[net]' > ~/.cargo/config.toml
        echo 'git-fetch-with-cli = true' >> ~/.cargo/config.toml
      shell: bash



================================================
FILE: .github/actions/setup-anchor/action.yaml
================================================
name: "Setup Anchor"
description: "Setup Anchor"
runs:
  using: "composite"
  steps:
    - uses: ./.github/actions/setup/
    - uses: ./.github/actions/setup-solana/
    - uses: actions/cache@v4
      name: Cache Anchor CLI
      id: cache-anchor-cli
      with:
        path: |
          ~/.cargo/bin/anchor
        key: anchor-cli-${{ runner.os }}-v0003-${{ env.ANCHOR_VERSION }}-${{ env.ANCHOR_COMMIT_HASH }}
        save-always: true
    # if ANCHOR_VERSION is 0, then install the anchor-cli from source
    - run: if [ $ANCHOR_VERSION -eq 0 ]; then cargo install --git https://github.com/solana-foundation/anchor --rev $ANCHOR_COMMIT_HASH anchor-cli --locked --force; else cargo install --git https://github.com/solana-foundation/anchor --tag "v$ANCHOR_VERSION" anchor-cli --locked; fi
      shell: bash
      if: steps.cache-anchor-cli.outputs.cache-hit != 'true'



================================================
FILE: .github/actions/setup-arcium/action.yaml
================================================
name: "Setup Arcium"
description: "Setup Arcium CLI using arcup"

runs:
  using: "composite"
  steps:
    - uses: ./.github/actions/setup/
    - uses: ./.github/actions/setup-anchor/

    # Install system dependencies (for Linux)
    - name: Install Linux Dependencies
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y pkg-config build-essential libudev-dev libssl-dev
      shell: bash

    # Determine target architecture
    - name: Set target architecture
      run: |
        if [ "$RUNNER_OS" == "Linux" ]; then
          if [ "$(uname -m)" == "aarch64" ]; then
            echo "ARCUP_TARGET=aarch64_linux" >> $GITHUB_ENV
          else
            echo "ARCUP_TARGET=x86_64_linux" >> $GITHUB_ENV
          fi
        elif [ "$RUNNER_OS" == "macOS" ]; then
          if [ "$(uname -m)" == "arm64" ]; then
            echo "ARCUP_TARGET=aarch64_macos" >> $GITHUB_ENV
          else
            echo "ARCUP_TARGET=x86_64_macos" >> $GITHUB_ENV
          fi
        fi
      shell: bash

    # Install arcup
    - name: Install arcup
      run: |
        curl "https://bin.arcium.com/download/arcup_${ARCUP_TARGET}_${{ env.ARCUP_VERSION }}" -o ~/.cargo/bin/arcup && \
        chmod +x ~/.cargo/bin/arcup
      shell: bash

    # Install Arcium CLI
    - name: Install Arcium CLI
      run: |
        arcup install
        arcium --version
      shell: bash



================================================
FILE: .github/actions/setup-solana/action.yaml
================================================
name: "Setup Solana"
description: "Setup Solana"
runs:
  using: "composite"
  steps:
    - uses: ./.github/actions/setup/
    - uses: actions/cache@v4
      name: Cache Solana Tool Suite
      id: cache-solana
      with:
        path: |
          ~/.cache/solana/
          ~/.local/share/solana/
        key: solana-${{ runner.os }}-v0000-${{ env.SOLANA_CLI_VERSION }}

    - run: sh -c "$(curl -sSfL https://release.anza.xyz/v${{ env.SOLANA_CLI_VERSION }}/install)"
      shell: bash
      if: steps.cache-solana.outputs.cache-hit != 'true'

    # Set PATH based on OS
    - name: Set Solana PATH
      run: |
        if [ "$RUNNER_OS" == "Linux" ]; then
          echo "/home/runner/.local/share/solana/install/active_release/bin" >> $GITHUB_PATH
          echo 'export PATH="/home/runner/.local/share/solana/install/active_release/bin:$PATH"' >> ~/.bashrc
        elif [ "$RUNNER_OS" == "macOS" ]; then
          echo "/Users/runner/.local/share/solana/install/active_release/bin" >> $GITHUB_PATH
          echo 'export PATH="/Users/runner/.local/share/solana/install/active_release/bin:$PATH"' >> ~/.bash_profile
        fi
      shell: bash

    # Source the profile and verify solana is available
    - name: Verify Solana installation
      run: |
        if [ "$RUNNER_OS" == "Linux" ]; then
          source ~/.bashrc
        elif [ "$RUNNER_OS" == "macOS" ]; then
          source ~/.bash_profile
        fi
        which solana
        solana --version
      shell: bash

    - run: solana-keygen new -s --no-bip39-passphrase --force
      shell: bash

    - run: solana config set --url localhost
      shell: bash



================================================
FILE: .github/workflows/fmt.yaml
================================================
name: Formatting Check
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always

jobs:
  fmt:
    name: Formatting
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup/

      - uses: actions-rs/toolchain@v1
        with:
          override: true
          components: rustfmt
          toolchain: nightly
      - run: rustup update

      # Find all example directories and their Cargo.lock files
      - name: Find example directories
        id: find-examples
        run: |
          echo "examples=$(find . -type f -name "Anchor.toml" -exec dirname {} \; | jq -R -s -c 'split("\n")[:-1]')" >> $GITHUB_OUTPUT
          echo "cargo_locks=$(find . -type f -name "Cargo.lock" | jq -R -s -c 'split("\n")[:-1]')" >> $GITHUB_OUTPUT

      # Check formatting on each example
      - name: Check formatting
        run: |
          EXAMPLES=$(echo '${{ steps.find-examples.outputs.examples }}' | jq -r '.[]')
          for example in $EXAMPLES; do
            echo "Checking formatting in $example"
            cd $example
            cargo +nightly fmt --all --check
            cd $GITHUB_WORKSPACE
          done



================================================
FILE: .github/workflows/test-examples.yaml
================================================
name: Test Examples
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  ARCUP_USER: testnet_user_20842437
  ARCUP_TOKEN: ${{ secrets.ARCUP_TOKEN }}

jobs:
  find-examples:
    runs-on: ubuntu-24.04
    outputs:
      matrix: ${{ steps.find-examples.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - name: Find example directories
        id: find-examples
        run: |
          echo "matrix=$(find . -type f -name "Anchor.toml" -exec dirname {} \; | jq -R -s -c '{example: split("\n")[:-1]}')" >> $GITHUB_OUTPUT

  test-examples:
    needs: find-examples
    name: Test ${{ matrix.example }}
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: false
      matrix: ${{fromJson(needs.find-examples.outputs.matrix)}}
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup/
      - uses: ./.github/actions/setup-solana/
      - uses: ./.github/actions/setup-anchor/
      - uses: ./.github/actions/setup-arcium/

      - name: Load cached cargo registry
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ./*/target
            ./*/*/target
          key: ${{ runner.os }}-cargo-${{ matrix.example }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-${{ matrix.example }}-

      - name: Test ${{ matrix.example }}
        run: |
          # Setup computation folders and vault
          rm -rf /tmp/computation_folder_0
          rm -rf /tmp/computation_folder_1
          rm -rf /tmp/computation_folder_2
          rm -rf /tmp/vault
          mkdir /tmp/vault

          if [[ "${{ matrix.example }}" = *"manticore"* ]]; then
            echo "Manticore test"
            cp -r ./examples/manticore/resources/computation_folder /tmp/computation_folder_0 
            rm -r /tmp/computation_folder_0/player-1

            cp -r ./examples/manticore/resources/computation_folder /tmp/computation_folder_1 
            rm -r /tmp/computation_folder_1/player-0

            cp -r ./examples/manticore/resources/computation_folder /tmp/computation_folder_2 
            rm -r /tmp/computation_folder_2/player-0
            rm -r /tmp/computation_folder_2/player-1
          else
            echo "Cerberus test"
            mkdir /tmp/computation_folder_0
            mkdir /tmp/computation_folder_1
            mkdir /tmp/computation_folder_2
          fi
          
          pushd ${{ matrix.example }}
          yarn install
          arcium build
          
          # Run the test and capture logs
          echo "Running arcium test..."
          timeout 10m arcium test || EXIT_CODE=$?
          echo "Most recent docker container id: $(docker ps -q -l)"
          docker logs $(docker ps -q -l)
          echo "=== Docker Containers ==="
          docker ps -a
          echo "=== Callback Server Logs ==="
          cat artifacts/callback_server.log || true
          echo "=== Docker Compose Logs ==="
          docker compose -f artifacts/docker-compose-arx-env.yml logs || true
          popd
          
          pkill -f solana-test-validator

          if [ -n "$EXIT_CODE" ]; then
            exit $EXIT_CODE
          fi

      - name: Save cargo registry
        uses: actions/cache/save@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ./*/target
            ./*/*/target
          key: ${{ runner.os }}-cargo-${{ matrix.example }}-${{ hashFiles('**/Cargo.lock') }}


